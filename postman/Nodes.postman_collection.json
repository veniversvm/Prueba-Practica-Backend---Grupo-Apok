{
  "info": {
    "_postman_id": "6c247d9b-2c50-4d5c-a269-87d1d116c324",
    "name": "Nodes",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "52193681",
    "_collection_link": "https://go.postman.co/collection/52193681-6c247d9b-2c50-4d5c-a269-87d1d116c324?source=collection_link"
  },
  "item": [
    {
      "name": "Get_Nodes",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Listar Nodos RaÃ­z (VERSIÃ“N ACTUALIZADA para tu API)",
              "// Endpoint: GET /api/nodes/ (o la ruta correcta)",
              "// ============================================",
              "",
              "console.log(\"=== Test: Listar Nodos RaÃ­z (Actualizado) ===\");",
              "",
              "// 1. Verificar cÃ³digo de estado",
              "pm.test(\"Status code es 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 2. Verificar que la respuesta es JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. Verificar estructura bÃ¡sica del array",
              "if (responseData && Array.isArray(responseData)) {",
              "    pm.test(\"Respuesta es un array\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "    ",
              "    // Si el array no estÃ¡ vacÃ­o, verificar estructura de los elementos",
              "    if (responseData.length > 0) {",
              "        const firstItem = responseData[0];",
              "        ",
              "        // 4. Verificar propiedades requeridas (ESTRUCTURA ACTUAL DE TU API)",
              "        pm.test(\"Elementos tienen estructura correcta\", function () {",
              "            // Verificar propiedades esenciales segÃºn tu API actual",
              "            pm.expect(firstItem).to.include.all.keys(",
              "                \"id\",",
              "                \"content\",  // Este es el campo principal en tu API actual",
              "                \"title\",    // Generado dinÃ¡micamente en el serializador",
              "                \"parent\",",
              "                \"children\",",
              "                \"created_at\"",
              "            );",
              "            // NOTA: created_by_name y updated_by_name NO existen en tu API actual",
              "        });",
              "        ",
              "        // 5. Verificar tipos de datos segÃºn tu API actual",
              "        pm.test(\"Tipos de datos correctos\", function () {",
              "            pm.expect(firstItem.id).to.be.a(\"number\");",
              "            pm.expect(firstItem.content).to.be.a(\"string\");  // Campo principal",
              "            pm.expect(firstItem.title).to.be.a(\"string\");    // Generado del ID",
              "            ",
              "            // parent puede ser null o number",
              "            pm.expect(firstItem.parent).to.satisfy((value) => {",
              "                return value === null || typeof value === \"number\";",
              "            }, \"parent debe ser null o number\");",
              "            ",
              "            // children es un array",
              "            pm.expect(firstItem.children).to.be.an(\"array\");",
              "            ",
              "            // created_at es string con formato personalizado",
              "            pm.expect(firstItem.created_at).to.be.a(\"string\");",
              "        });",
              "        ",
              "        // 6. Verificar que son nodos raÃ­z (parent es null)",
              "        pm.test(\"Todos los nodos son raÃ­z (parent es null)\", function () {",
              "            const allRoots = responseData.every(item => item.parent === null);",
              "            pm.expect(allRoots).to.be.true;",
              "        });",
              "        ",
              "        // 7. Verificar que IDs son Ãºnicos y positivos",
              "        pm.test(\"IDs son Ãºnicos y positivos\", function () {",
              "            const ids = responseData.map(item => item.id);",
              "            const uniqueIds = [...new Set(ids)];",
              "            ",
              "            pm.expect(ids.length).to.equal(uniqueIds.length, \"IDs deben ser Ãºnicos\");",
              "            ",
              "            const allPositive = ids.every(id => id > 0);",
              "            pm.expect(allPositive).to.be.true;",
              "        });",
              "        ",
              "        // 8. Verificar formato de fecha (formato actual de tu API)",
              "        pm.test(\"Fecha created_at tiene formato vÃ¡lido\", function () {",
              "            const dateString = firstItem.created_at;",
              "            // Formato actual: \"2024-01-15 10:00:00\" (sin UTC, con zona horaria del header)",
              "            pm.expect(dateString).to.match(",
              "                /\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}/, ",
              "                \"Formato de fecha esperado: YYYY-MM-DD HH:MM:SS\"",
              "            );",
              "        });",
              "        ",
              "        // 9. Verificar que children es siempre un array",
              "        pm.test(\"Children es siempre un array\", function () {",
              "            const allArrays = responseData.every(item => Array.isArray(item.children));",
              "            pm.expect(allArrays).to.be.true;",
              "        });",
              "        ",
              "        // 10. Verificar que content no estÃ¡ vacÃ­o (campo principal en tu API)",
              "        pm.test(\"Content no estÃ¡ vacÃ­o\", function () {",
              "            const allContentValid = responseData.every(item => ",
              "                item.content && item.content.trim().length > 0",
              "            );",
              "            pm.expect(allContentValid).to.be.true;",
              "        });",
              "        ",
              "        // 11. Verificar que title estÃ¡ basado en ID (num2words)",
              "        pm.test(\"Title es texto y no estÃ¡ vacÃ­o\", function () {",
              "            const allTitlesValid = responseData.every(item => ",
              "                item.title && item.title.trim().length > 0",
              "            );",
              "            pm.expect(allTitlesValid).to.be.true;",
              "        });",
              "        ",
              "        // 12. Mostrar informaciÃ³n para debugging",
              "        console.log(`âœ“ Encontrados ${responseData.length} nodos raÃ­z`);",
              "        console.log(`âœ“ Primer nodo: ID=${firstItem.id}, Content=\"${firstItem.content}\", Title=\"${firstItem.title}\"`);",
              "        ",
              "        console.log(\"Nodos raÃ­z encontrados:\");",
              "        responseData.forEach((nodo, index) => {",
              "            console.log(`  ${index + 1}. ID: ${nodo.id}, Content: \"${nodo.content}\", Title: \"${nodo.title}\"`);",
              "        });",
              "        ",
              "    } else {",
              "        // Array vacÃ­o - tambiÃ©n es una respuesta vÃ¡lida",
              "        pm.test(\"Array puede estar vacÃ­o (sin nodos raÃ­z)\", function () {",
              "            pm.expect(responseData.length).to.equal(0);",
              "        });",
              "        console.log(\"âœ“ No hay nodos raÃ­z (array vacÃ­o)\");",
              "    }",
              "}",
              "",
              "// 13. Verificar headers de cachÃ© (180 segundos) - OPCIONAL",
              "pm.test(\"Headers de cachÃ© configurados\", function () {",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    ",
              "    if (cacheControl) {",
              "        console.log(`Cache-Control: ${cacheControl}`);",
              "        // Cache puede variar, solo verificar que existe",
              "        pm.expect(cacheControl).to.not.be.empty;",
              "    } else {",
              "        console.log(\"âš  No se encontrÃ³ header Cache-Control (puede ser normal)\");",
              "    }",
              "});",
              "",
              "// 14. Verificar tiempo de respuesta",
              "pm.test(\"Tiempo de respuesta aceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    console.log(`âœ“ Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 15. Verificar Content-Type",
              "pm.test(\"Content-Type es application/json\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ“ Content-Type: ${contentType}`);",
              "});",
              "",
              "// 16. Verificar que no hay errores en la respuesta",
              "pm.test(\"Respuesta no contiene errores\", function () {",
              "    if (responseData && typeof responseData === \"object\") {",
              "        pm.expect(responseData).to.not.have.property(\"error\");",
              "        pm.expect(responseData).to.not.have.property(\"message\");",
              "        pm.expect(responseData).to.not.have.property(\"detail\");",
              "    }",
              "});",
              "",
              "// 17. ValidaciÃ³n de data integrity",
              "if (responseData && responseData.length > 0) {",
              "    pm.test(\"Integridad de datos\", function () {",
              "        responseData.forEach((item, index) => {",
              "            // Verificar campos requeridos",
              "            pm.expect(item.id).to.exist;",
              "            pm.expect(item.content).to.exist;",
              "            pm.expect(item.title).to.exist;",
              "            pm.expect(item.created_at).to.exist;",
              "            ",
              "            // Verificar que ID es nÃºmero entero",
              "            pm.expect(Number.isInteger(item.id)).to.be.true;",
              "            ",
              "            // Verificar que content no es solo espacios",
              "            pm.expect(item.content.trim().length).to.be.greaterThan(0, ",
              "                `Item ${index} (ID: ${item.id}) tiene content vacÃ­o`",
              "            );",
              "        });",
              "    });",
              "}",
              "",
              "// 18. Verificar paginaciÃ³n si existe",
              "pm.test(\"Verificar estructura de paginaciÃ³n si aplica\", function () {",
              "    // Si tu API usa paginaciÃ³n, la respuesta podrÃ­a ser un objeto con results",
              "    // Si no usa paginaciÃ³n, es un array directamente",
              "    if (responseData && typeof responseData === 'object' && !Array.isArray(responseData)) {",
              "        // Es respuesta paginada",
              "        pm.expect(responseData).to.have.property(\"count\");",
              "        pm.expect(responseData).to.have.property(\"results\");",
              "        pm.expect(responseData.results).to.be.an(\"array\");",
              "        console.log(\"âœ“ Respuesta paginada detectada\");",
              "    }",
              "    // Si es array directamente, no hay problema",
              "});",
              "",
              "console.log(\"=== Test completado ===\");",
              "",
              "// 19. Guardar datos para tests futuros (OPCIONAL)",
              "if (responseData && responseData.length > 0) {",
              "    let nodosData;",
              "    ",
              "    // Manejar si es respuesta paginada o array directo",
              "    if (Array.isArray(responseData)) {",
              "        nodosData = responseData;",
              "    } else if (responseData.results && Array.isArray(responseData.results)) {",
              "        nodosData = responseData.results;",
              "    }",
              "    ",
              "    if (nodosData && nodosData.length > 0) {",
              "        pm.environment.set(\"primer_nodo_raiz_id\", nodosData[0].id);",
              "        pm.environment.set(\"primer_nodo_raiz_content\", nodosData[0].content);",
              "        pm.environment.set(\"total_nodos_raiz\", nodosData.length);",
              "        ",
              "        console.log(`âœ“ Datos guardados para tests futuros:`);",
              "        console.log(`  - Primer nodo: ID=${nodosData[0].id}, Content=\"${nodosData[0].content}\"`);",
              "        console.log(`  - Total nodos: ${nodosData.length}`);",
              "    }",
              "}",
              "",
              "// 20. Pruebas especÃ­ficas para caracterÃ­sticas de tu API",
              "pm.test(\"Verificar caracterÃ­sticas especÃ­ficas de la API\", function () {",
              "    // Verificar que title estÃ¡ relacionado con ID (es num2words)",
              "    if (responseData && responseData.length > 0) {",
              "        const firstItem = Array.isArray(responseData) ? responseData[0] : ",
              "                         (responseData.results ? responseData.results[0] : null);",
              "        ",
              "        if (firstItem) {",
              "            // Title deberÃ­a ser una palabra, no un nÃºmero",
              "            const title = firstItem.title.toLowerCase();",
              "            const isNumber = /^\\d+$/.test(title);",
              "            pm.expect(isNumber).to.be.false;",
              "            ",
              "            // Content deberÃ­a ser diferente de title",
              "            pm.expect(firstItem.content).to.not.equal(firstItem.title);",
              "        }",
              "    }",
              "});",
              "",
              "// 21. Verificar profundidad de children (si se pasÃ³ parÃ¡metro depth)",
              "const url = pm.request.url.toString();",
              "if (url.includes(\"depth=\")) {",
              "    pm.test(\"ParÃ¡metro depth funciona correctamente\", function () {",
              "        console.log(`âœ“ ParÃ¡metro depth detectado en URL: ${url}`);",
              "        // Puedes agregar verificaciones especÃ­ficas para depth aquÃ­",
              "    });",
              "}",
              "",
              "// 22. Verificar headers de idioma y zona horaria",
              "pm.test(\"Headers personalizados procesados\", function () {",
              "    const acceptLanguage = pm.request.headers.get(\"Accept-Language\");",
              "    const timeZone = pm.request.headers.get(\"Time-Zone\");",
              "    ",
              "    if (acceptLanguage) {",
              "        console.log(`âœ“ Accept-Language: ${acceptLanguage}`);",
              "    }",
              "    ",
              "    if (timeZone) {",
              "        console.log(`âœ“ Time-Zone: ${timeZone}`);",
              "    }",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Must_Fail_No_Token",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// TEST SIMPLIFICADO - Listar Nodos RaÃ­z 401",
              "",
              "console.log(\"=== Test Simple: Error 401 ===\");",
              "",
              "// 1. Status code",
              "pm.test(\"Status 401 Unauthorized\", function() {",
              "    pm.response.to.have.status(401);",
              "});",
              "",
              "// 2. Mensaje de error",
              "const response = pm.response.json();",
              "pm.test(\"Mensaje de error correcto\", function() {",
              "    pm.expect(response.detail).to.equal(\"Authentication credentials were not provided.\");",
              "});",
              "",
              "// 3. Headers bÃ¡sicos",
              "pm.test(\"Headers bÃ¡sicos correctos\", function() {",
              "    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
              "    pm.expect(pm.response.headers.get(\"WWW-Authenticate\")).to.equal(\"Bearer realm=\\\"api\\\"\");",
              "});",
              "",
              "// 4. Seguridad",
              "pm.test(\"Headers de seguridad\", function() {",
              "    pm.expect(pm.response.headers.get(\"X-Content-Type-Options\")).to.equal(\"nosniff\");",
              "    pm.expect(pm.response.headers.get(\"X-Frame-Options\")).to.equal(\"DENY\");",
              "});",
              "",
              "console.log(\"âœ… Test 401 completado\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Must_Fail_Bad_token",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// TEST ESPECÃFICO: Token invÃ¡lido (refresh token usado como access token)",
              "",
              "console.log(\"=== Test: Error 401 - Token invÃ¡lido especÃ­fico ===\");",
              "",
              "// 1. Status 401",
              "pm.test(\"Status 401 Unauthorized\", function() {",
              "    pm.response.to.have.status(401);",
              "});",
              "",
              "// 2. Parse response",
              "const response = pm.response.json();",
              "",
              "// 3. Validar estructura exacta del error de token invÃ¡lido",
              "pm.test(\"Estructura de error de token invÃ¡lido\", function() {",
              "    // Propiedades principales",
              "    pm.expect(response).to.have.all.keys([\"detail\", \"code\", \"messages\"]);",
              "    ",
              "    // Valores especÃ­ficos",
              "    pm.expect(response.detail).to.equal(\"Given token not valid for any token type\");",
              "    pm.expect(response.code).to.equal(\"token_not_valid\");",
              "    ",
              "    // Messages array",
              "    pm.expect(response.messages).to.be.an(\"array\").with.lengthOf(1);",
              "});",
              "",
              "// 4. Validar el primer mensaje de error",
              "if (response.messages && response.messages[0]) {",
              "    const msg = response.messages[0];",
              "    ",
              "    pm.test(\"Mensaje de error detallado\", function() {",
              "        pm.expect(msg.token_class).to.equal(\"AccessToken\");",
              "        pm.expect(msg.token_type).to.equal(\"access\");",
              "        pm.expect(msg.message).to.equal(\"Token has wrong type\");",
              "    });",
              "    ",
              "    console.log(`Error especÃ­fico: ${msg.message}`);",
              "    console.log(`Tipo de token esperado: ${msg.token_type}`);",
              "}",
              "",
              "// 5. Headers",
              "pm.test(\"Headers bÃ¡sicos\", function() {",
              "    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");",
              "    // WWW-Authenticate puede o no estar presente en este caso",
              "});",
              "",
              "// 6. Performance",
              "pm.test(\"Respuesta rÃ¡pida\", function() {",
              "    pm.expect(pm.response.responseTime).to.be.below(100);",
              "});",
              "",
              "console.log(\"âœ… Test de token invÃ¡lido completado\");",
              "",
              "// 7. Ayuda para debugging",
              "console.log(\"\\n=== INFO PARA DEBUGGING ===\");",
              "console.log(\"EstÃ¡s enviando probablemente un REFRESH token como ACCESS token.\");",
              "console.log(\"Recuerda:\");",
              "console.log(\"- Access token: Para autenticar requests (vence rÃ¡pido)\");",
              "console.log(\"- Refresh token: Solo para obtener nuevo access token\");",
              "console.log(\"SoluciÃ³n: Usa el endpoint /api/token/refresh/ con el refresh token para obtener un nuevo access token vÃ¡lido.\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{refresh_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Deep_1",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Get Nodes List with Depth Parameter",
              "// Endpoint: GET /api/nodes/?depth=1",
              "// ============================================",
              "",
              "console.log(\"=== Test: Get Nodes List with Depth Parameter ===\");",
              "",
              "// 1. Get the URL",
              "const url = pm.request.url.toString();",
              "console.log(`Request URL: ${url}`);",
              "",
              "// 2. Check if depth parameter is present",
              "const hasDepthParam = url.includes(\"depth=\");",
              "console.log(`Depth parameter in URL: ${hasDepthParam ? 'Yes' : 'No'}`);",
              "",
              "if (hasDepthParam) {",
              "    pm.test(\"URL contains depth parameter\", function () {",
              "        pm.expect(url).to.include(\"depth=\");",
              "    });",
              "    ",
              "    // Extract depth value if present",
              "    const depthMatch = url.match(/depth=(\\d+|-1)/);",
              "    if (depthMatch) {",
              "        const depthValue = depthMatch[1];",
              "        console.log(`âœ“ Depth value: ${depthValue}`);",
              "        pm.environment.set(\"requested_depth\", depthValue);",
              "    }",
              "}",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON array\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Check if response is empty",
              "if (!responseData || responseData.length === 0) {",
              "    console.log(\"Response is empty array\");",
              "    pm.test(\"Empty response is valid\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\").that.is.empty;",
              "    });",
              "    console.log(\"âœ… Test completed - empty response\");",
              "    return;",
              "}",
              "",
              "console.log(`âœ“ Response contains ${responseData.length} nodes`);",
              "",
              "// 6. CORREGIDO: Verify structure for all nodes",
              "pm.test(\"All nodes have correct structure\", function () {",
              "    responseData.forEach((node, index) => {",
              "        // Verificar que existe cada propiedad",
              "        pm.expect(node).to.have.property(\"id\");",
              "        pm.expect(node).to.have.property(\"content\");",
              "        pm.expect(node).to.have.property(\"title\");",
              "        pm.expect(node).to.have.property(\"parent\");",
              "        pm.expect(node).to.have.property(\"children\");",
              "        pm.expect(node).to.have.property(\"created_at\");",
              "        ",
              "        // Validar tipos de datos",
              "        pm.expect(node.id).to.be.a(\"number\").and.to.be.greaterThan(0);",
              "        pm.expect(node.content).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "        pm.expect(node.title).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "        pm.expect(node.children).to.be.an(\"array\");",
              "        pm.expect(node.created_at).to.be.a(\"string\");",
              "        ",
              "        // Todos los nodos en /api/nodes/ deben ser raÃ­z",
              "        pm.expect(node.parent).to.be.null;",
              "    });",
              "    console.log(`âœ“ All ${responseData.length} nodes have correct structure`);",
              "});",
              "",
              "// 7. Check depth behavior",
              "if (hasDepthParam) {",
              "    const depthValue = pm.environment.get(\"requested_depth\") || \"1\";",
              "    console.log(`\\nðŸ” Testing depth=${depthValue} behavior:`);",
              "    ",
              "    if (depthValue === \"0\") {",
              "        pm.test(\"Depth=0: No children should be shown\", function () {",
              "            const nodesWithChildren = responseData.filter(node => node.children.length > 0);",
              "            pm.expect(nodesWithChildren.length).to.equal(0, ",
              "                `Found ${nodesWithChildren.length} nodes with children (should be 0)`);",
              "        });",
              "    } ",
              "    else if (depthValue === \"1\") {",
              "        pm.test(\"Depth=1: Only immediate children, no grandchildren\", function () {",
              "            let violations = 0;",
              "            ",
              "            responseData.forEach((node) => {",
              "                if (node.children.length > 0) {",
              "                    node.children.forEach((child) => {",
              "                        // Cada hijo debe tener array de hijos vacÃ­o",
              "                        if (child.children && child.children.length > 0) {",
              "                            violations++;",
              "                        }",
              "                    });",
              "                }",
              "            });",
              "            ",
              "            pm.expect(violations).to.equal(0,",
              "                `Found ${violations} children that have their own children (violates depth=1)`);",
              "            ",
              "            if (violations === 0) {",
              "                console.log(`âœ“ Depth=1 constraint verified - no grandchildren found`);",
              "            }",
              "        });",
              "    }",
              "    else {",
              "        console.log(`Depth=${depthValue}: Testing nested structure`);",
              "        // Para depth > 1, verificamos que la estructura sea consistente",
              "        pm.test(`Depth=${depthValue} structure is consistent`, function () {",
              "            responseData.forEach(node => {",
              "                pm.expect(node.children).to.be.an(\"array\");",
              "            });",
              "        });",
              "    }",
              "} else {",
              "    console.log(\"\\nâš  No depth parameter - testing default behavior\");",
              "}",
              "",
              "// 8. Validate specific fields",
              "pm.test(\"Title fields are valid (num2words)\", function () {",
              "    let invalidTitles = 0;",
              "    ",
              "    responseData.slice(0, 5).forEach((node) => { // Revisar primeros 5 nodos",
              "        const title = node.title;",
              "        // No debe ser solo nÃºmeros",
              "        const isOnlyNumbers = /^\\d+$/.test(title);",
              "        if (isOnlyNumbers) {",
              "            invalidTitles++;",
              "            console.log(`âš  Node ${node.id} has numeric title: \"${title}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(invalidTitles).to.equal(0, `Found ${invalidTitles} nodes with numeric titles`);",
              "    ",
              "    if (invalidTitles === 0) {",
              "        console.log(\"âœ“ Title validation passed - all titles are text-based\");",
              "    }",
              "});",
              "",
              "// 9. Validate dates",
              "pm.test(\"Created_at fields have correct format\", function () {",
              "    let invalidDates = 0;",
              "    ",
              "    responseData.forEach((node) => {",
              "        const datePattern = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "        if (!datePattern.test(node.created_at)) {",
              "            invalidDates++;",
              "            console.log(`âš  Node ${node.id} has invalid date format: \"${node.created_at}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(invalidDates).to.equal(0, `Found ${invalidDates} nodes with invalid date format`);",
              "    ",
              "    if (invalidDates === 0) {",
              "        console.log(\"âœ“ All dates have correct format\");",
              "    }",
              "});",
              "",
              "// 10. Verify parent-child relationships for nodes with children",
              "pm.test(\"Parent-child relationships are correct\", function () {",
              "    let incorrectRelationships = 0;",
              "    ",
              "    responseData.forEach((node) => {",
              "        if (node.children.length > 0) {",
              "            node.children.forEach((child) => {",
              "                if (child.parent !== node.id) {",
              "                    incorrectRelationships++;",
              "                    console.log(`âš  Child ${child.id} has parent ${child.parent}, expected ${node.id}`);",
              "                }",
              "            });",
              "        }",
              "    });",
              "    ",
              "    pm.expect(incorrectRelationships).to.equal(0,",
              "        `Found ${incorrectRelationships} incorrect parent-child relationships`);",
              "    ",
              "    if (incorrectRelationships === 0) {",
              "        console.log(\"âœ“ All parent-child relationships are correct\");",
              "    }",
              "});",
              "",
              "// 11. Show statistics",
              "console.log(`\\nðŸ“Š RESPONSE STATISTICS:`);",
              "console.log(`Total nodes: ${responseData.length}`);",
              "",
              "const nodesWithChildren = responseData.filter(node => node.children.length > 0).length;",
              "console.log(`Nodes with children: ${nodesWithChildren}`);",
              "",
              "const totalChildren = responseData.reduce((sum, node) => sum + node.children.length, 0);",
              "console.log(`Total children: ${totalChildren}`);",
              "",
              "const avgChildrenPerNode = nodesWithChildren > 0 ? (totalChildren / nodesWithChildren).toFixed(2) : 0;",
              "console.log(`Average children per node (with children): ${avgChildrenPerNode}`);",
              "",
              "// 12. Performance check",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    const time = pm.response.responseTime;",
              "    console.log(`\\nâ± Performance: ${time}ms`);",
              "    ",
              "    if (time > 1000) {",
              "        console.log(\"âš  Response time > 1 second\");",
              "    }",
              "});",
              "",
              "// 13. Response headers",
              "pm.test(\"Response headers are valid\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ“ Content-Type: ${contentType}`);",
              "    ",
              "    // Check cache headers if present",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    if (cacheControl) {",
              "        console.log(`âœ“ Cache-Control: ${cacheControl}`);",
              "    }",
              "});",
              "",
              "// 14. Save useful data for future tests",
              "if (responseData.length > 0) {",
              "    // Save first node",
              "    const firstNode = responseData[0];",
              "    pm.environment.set(\"first_root_node_id\", firstNode.id.toString());",
              "    pm.environment.set(\"first_root_node_content\", firstNode.content);",
              "    console.log(`âœ“ First node saved: ID ${firstNode.id}`);",
              "    ",
              "    // Find and save a node with children",
              "    const nodeWithChildren = responseData.find(node => node.children.length > 0);",
              "    if (nodeWithChildren) {",
              "        pm.environment.set(\"node_with_children_id\", nodeWithChildren.id.toString());",
              "        pm.environment.set(\"node_with_children_content\", nodeWithChildren.content);",
              "        pm.environment.set(\"node_with_children_child_count\", nodeWithChildren.children.length.toString());",
              "        ",
              "        // Save first child ID",
              "        if (nodeWithChildren.children.length > 0) {",
              "            const firstChild = nodeWithChildren.children[0];",
              "            pm.environment.set(\"first_child_id\", firstChild.id.toString());",
              "            pm.environment.set(\"first_child_content\", firstChild.content);",
              "            console.log(`âœ“ Node with children saved: ID ${nodeWithChildren.id} (${nodeWithChildren.children.length} children)`);",
              "        }",
              "    }",
              "    ",
              "    // Save all node IDs for potential future use",
              "    const allNodeIds = responseData.map(node => node.id);",
              "    pm.environment.set(\"all_root_node_ids\", JSON.stringify(allNodeIds));",
              "}",
              "",
              "// 15. Final summary",
              "console.log(`\\nâœ… TEST SUMMARY:`);",
              "console.log(`   Request: ${pm.request.method} ${url.split('?')[0]}`);",
              "console.log(`   Parameters: ${hasDepthParam ? 'depth=' + (pm.environment.get(\"requested_depth\") || \"1\") : 'none'}`);",
              "console.log(`   Response: ${responseData.length} root nodes`);",
              "console.log(`   Status: ${pm.response.code} OK`);",
              "console.log(`   Time: ${pm.response.responseTime}ms`);",
              "console.log(`   Depth validation: ${hasDepthParam ? 'PASSED' : 'NOT TESTED'}`);",
              "",
              "console.log(\"\\nðŸŽ¯ Test completed successfully!\");",
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/?depth=1",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ],
          "query": [
            {
              "key": "depth",
              "value": "1"
            }
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Deep_2",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Get Nodes List with Depth Parameter",
              "// Endpoint: GET /api/nodes/?depth=1",
              "// ============================================",
              "",
              "console.log(\"=== Test: Get Nodes List with Depth Parameter ===\");",
              "",
              "// 1. Get the URL",
              "const url = pm.request.url.toString();",
              "console.log(`Request URL: ${url}`);",
              "",
              "// 2. Check if depth parameter is present",
              "const hasDepthParam = url.includes(\"depth=\");",
              "console.log(`Depth parameter in URL: ${hasDepthParam ? 'Yes' : 'No'}`);",
              "",
              "if (hasDepthParam) {",
              "    pm.test(\"URL contains depth parameter\", function () {",
              "        pm.expect(url).to.include(\"depth=\");",
              "    });",
              "    ",
              "    // Extract depth value if present",
              "    const depthMatch = url.match(/depth=(\\d+|-1)/);",
              "    if (depthMatch) {",
              "        const depthValue = depthMatch[1];",
              "        console.log(`âœ“ Depth value: ${depthValue}`);",
              "        pm.environment.set(\"requested_depth\", depthValue);",
              "    }",
              "}",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON array\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Check if response is empty",
              "if (!responseData || responseData.length === 0) {",
              "    console.log(\"Response is empty array\");",
              "    pm.test(\"Empty response is valid\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\").that.is.empty;",
              "    });",
              "    console.log(\"âœ… Test completed - empty response\");",
              "    return;",
              "}",
              "",
              "console.log(`âœ“ Response contains ${responseData.length} nodes`);",
              "",
              "// 6. CORREGIDO: Verify structure for all nodes",
              "pm.test(\"All nodes have correct structure\", function () {",
              "    responseData.forEach((node, index) => {",
              "        // Verificar que existe cada propiedad",
              "        pm.expect(node).to.have.property(\"id\");",
              "        pm.expect(node).to.have.property(\"content\");",
              "        pm.expect(node).to.have.property(\"title\");",
              "        pm.expect(node).to.have.property(\"parent\");",
              "        pm.expect(node).to.have.property(\"children\");",
              "        pm.expect(node).to.have.property(\"created_at\");",
              "        ",
              "        // Validar tipos de datos",
              "        pm.expect(node.id).to.be.a(\"number\").and.to.be.greaterThan(0);",
              "        pm.expect(node.content).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "        pm.expect(node.title).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "        pm.expect(node.children).to.be.an(\"array\");",
              "        pm.expect(node.created_at).to.be.a(\"string\");",
              "        ",
              "        // Todos los nodos en /api/nodes/ deben ser raÃ­z",
              "        pm.expect(node.parent).to.be.null;",
              "    });",
              "    console.log(`âœ“ All ${responseData.length} nodes have correct structure`);",
              "});",
              "",
              "// 7. Check depth behavior",
              "if (hasDepthParam) {",
              "    const depthValue = pm.environment.get(\"requested_depth\") || \"1\";",
              "    console.log(`\\nðŸ” Testing depth=${depthValue} behavior:`);",
              "    ",
              "    if (depthValue === \"0\") {",
              "        pm.test(\"Depth=0: No children should be shown\", function () {",
              "            const nodesWithChildren = responseData.filter(node => node.children.length > 0);",
              "            pm.expect(nodesWithChildren.length).to.equal(0, ",
              "                `Found ${nodesWithChildren.length} nodes with children (should be 0)`);",
              "        });",
              "    } ",
              "    else if (depthValue === \"1\") {",
              "        pm.test(\"Depth=1: Only immediate children, no grandchildren\", function () {",
              "            let violations = 0;",
              "            ",
              "            responseData.forEach((node) => {",
              "                if (node.children.length > 0) {",
              "                    node.children.forEach((child) => {",
              "                        // Cada hijo debe tener array de hijos vacÃ­o",
              "                        if (child.children && child.children.length > 0) {",
              "                            violations++;",
              "                        }",
              "                    });",
              "                }",
              "            });",
              "            ",
              "            pm.expect(violations).to.equal(0,",
              "                `Found ${violations} children that have their own children (violates depth=1)`);",
              "            ",
              "            if (violations === 0) {",
              "                console.log(`âœ“ Depth=1 constraint verified - no grandchildren found`);",
              "            }",
              "        });",
              "    }",
              "    else {",
              "        console.log(`Depth=${depthValue}: Testing nested structure`);",
              "        // Para depth > 1, verificamos que la estructura sea consistente",
              "        pm.test(`Depth=${depthValue} structure is consistent`, function () {",
              "            responseData.forEach(node => {",
              "                pm.expect(node.children).to.be.an(\"array\");",
              "            });",
              "        });",
              "    }",
              "} else {",
              "    console.log(\"\\nâš  No depth parameter - testing default behavior\");",
              "}",
              "",
              "// 8. Validate specific fields",
              "pm.test(\"Title fields are valid (num2words)\", function () {",
              "    let invalidTitles = 0;",
              "    ",
              "    responseData.slice(0, 5).forEach((node) => { // Revisar primeros 5 nodos",
              "        const title = node.title;",
              "        // No debe ser solo nÃºmeros",
              "        const isOnlyNumbers = /^\\d+$/.test(title);",
              "        if (isOnlyNumbers) {",
              "            invalidTitles++;",
              "            console.log(`âš  Node ${node.id} has numeric title: \"${title}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(invalidTitles).to.equal(0, `Found ${invalidTitles} nodes with numeric titles`);",
              "    ",
              "    if (invalidTitles === 0) {",
              "        console.log(\"âœ“ Title validation passed - all titles are text-based\");",
              "    }",
              "});",
              "",
              "// 9. Validate dates",
              "pm.test(\"Created_at fields have correct format\", function () {",
              "    let invalidDates = 0;",
              "    ",
              "    responseData.forEach((node) => {",
              "        const datePattern = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "        if (!datePattern.test(node.created_at)) {",
              "            invalidDates++;",
              "            console.log(`âš  Node ${node.id} has invalid date format: \"${node.created_at}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(invalidDates).to.equal(0, `Found ${invalidDates} nodes with invalid date format`);",
              "    ",
              "    if (invalidDates === 0) {",
              "        console.log(\"âœ“ All dates have correct format\");",
              "    }",
              "});",
              "",
              "// 10. Verify parent-child relationships for nodes with children",
              "pm.test(\"Parent-child relationships are correct\", function () {",
              "    let incorrectRelationships = 0;",
              "    ",
              "    responseData.forEach((node) => {",
              "        if (node.children.length > 0) {",
              "            node.children.forEach((child) => {",
              "                if (child.parent !== node.id) {",
              "                    incorrectRelationships++;",
              "                    console.log(`âš  Child ${child.id} has parent ${child.parent}, expected ${node.id}`);",
              "                }",
              "            });",
              "        }",
              "    });",
              "    ",
              "    pm.expect(incorrectRelationships).to.equal(0,",
              "        `Found ${incorrectRelationships} incorrect parent-child relationships`);",
              "    ",
              "    if (incorrectRelationships === 0) {",
              "        console.log(\"âœ“ All parent-child relationships are correct\");",
              "    }",
              "});",
              "",
              "// 11. Show statistics",
              "console.log(`\\nðŸ“Š RESPONSE STATISTICS:`);",
              "console.log(`Total nodes: ${responseData.length}`);",
              "",
              "const nodesWithChildren = responseData.filter(node => node.children.length > 0).length;",
              "console.log(`Nodes with children: ${nodesWithChildren}`);",
              "",
              "const totalChildren = responseData.reduce((sum, node) => sum + node.children.length, 0);",
              "console.log(`Total children: ${totalChildren}`);",
              "",
              "const avgChildrenPerNode = nodesWithChildren > 0 ? (totalChildren / nodesWithChildren).toFixed(2) : 0;",
              "console.log(`Average children per node (with children): ${avgChildrenPerNode}`);",
              "",
              "// 12. Performance check",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    const time = pm.response.responseTime;",
              "    console.log(`\\nâ± Performance: ${time}ms`);",
              "    ",
              "    if (time > 1000) {",
              "        console.log(\"âš  Response time > 1 second\");",
              "    }",
              "});",
              "",
              "// 13. Response headers",
              "pm.test(\"Response headers are valid\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ“ Content-Type: ${contentType}`);",
              "    ",
              "    // Check cache headers if present",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    if (cacheControl) {",
              "        console.log(`âœ“ Cache-Control: ${cacheControl}`);",
              "    }",
              "});",
              "",
              "// 14. Save useful data for future tests",
              "if (responseData.length > 0) {",
              "    // Save first node",
              "    const firstNode = responseData[0];",
              "    pm.environment.set(\"first_root_node_id\", firstNode.id.toString());",
              "    pm.environment.set(\"first_root_node_content\", firstNode.content);",
              "    console.log(`âœ“ First node saved: ID ${firstNode.id}`);",
              "    ",
              "    // Find and save a node with children",
              "    const nodeWithChildren = responseData.find(node => node.children.length > 0);",
              "    if (nodeWithChildren) {",
              "        pm.environment.set(\"node_with_children_id\", nodeWithChildren.id.toString());",
              "        pm.environment.set(\"node_with_children_content\", nodeWithChildren.content);",
              "        pm.environment.set(\"node_with_children_child_count\", nodeWithChildren.children.length.toString());",
              "        ",
              "        // Save first child ID",
              "        if (nodeWithChildren.children.length > 0) {",
              "            const firstChild = nodeWithChildren.children[0];",
              "            pm.environment.set(\"first_child_id\", firstChild.id.toString());",
              "            pm.environment.set(\"first_child_content\", firstChild.content);",
              "            console.log(`âœ“ Node with children saved: ID ${nodeWithChildren.id} (${nodeWithChildren.children.length} children)`);",
              "        }",
              "    }",
              "    ",
              "    // Save all node IDs for potential future use",
              "    const allNodeIds = responseData.map(node => node.id);",
              "    pm.environment.set(\"all_root_node_ids\", JSON.stringify(allNodeIds));",
              "}",
              "",
              "// 15. Final summary",
              "console.log(`\\nâœ… TEST SUMMARY:`);",
              "console.log(`   Request: ${pm.request.method} ${url.split('?')[0]}`);",
              "console.log(`   Parameters: ${hasDepthParam ? 'depth=' + (pm.environment.get(\"requested_depth\") || \"1\") : 'none'}`);",
              "console.log(`   Response: ${responseData.length} root nodes`);",
              "console.log(`   Status: ${pm.response.code} OK`);",
              "console.log(`   Time: ${pm.response.responseTime}ms`);",
              "console.log(`   Depth validation: ${hasDepthParam ? 'PASSED' : 'NOT TESTED'}`);",
              "",
              "console.log(\"\\nðŸŽ¯ Test completed successfully!\");",
              "",
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/?depth=2",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ],
          "query": [
            {
              "key": "depth",
              "value": "2"
            }
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Deep_3",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Get Nodes List with Depth Parameter",
              "// Endpoint: GET /api/nodes/?depth=1",
              "// ============================================",
              "",
              "console.log(\"=== Test: Get Nodes List with Depth Parameter ===\");",
              "",
              "// 1. Get the URL",
              "const url = pm.request.url.toString();",
              "console.log(`Request URL: ${url}`);",
              "",
              "// 2. Check if depth parameter is present",
              "const hasDepthParam = url.includes(\"depth=\");",
              "console.log(`Depth parameter in URL: ${hasDepthParam ? 'Yes' : 'No'}`);",
              "",
              "if (hasDepthParam) {",
              "    pm.test(\"URL contains depth parameter\", function () {",
              "        pm.expect(url).to.include(\"depth=\");",
              "    });",
              "    ",
              "    // Extract depth value if present",
              "    const depthMatch = url.match(/depth=(\\d+|-1)/);",
              "    if (depthMatch) {",
              "        const depthValue = depthMatch[1];",
              "        console.log(`âœ“ Depth value: ${depthValue}`);",
              "        pm.environment.set(\"requested_depth\", depthValue);",
              "    }",
              "}",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON array\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Check if response is empty",
              "if (!responseData || responseData.length === 0) {",
              "    console.log(\"Response is empty array\");",
              "    pm.test(\"Empty response is valid\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\").that.is.empty;",
              "    });",
              "    console.log(\"âœ… Test completed - empty response\");",
              "    return;",
              "}",
              "",
              "console.log(`âœ“ Response contains ${responseData.length} nodes`);",
              "",
              "// 6. CORREGIDO: Verify structure for all nodes",
              "pm.test(\"All nodes have correct structure\", function () {",
              "    responseData.forEach((node, index) => {",
              "        // Verificar que existe cada propiedad",
              "        pm.expect(node).to.have.property(\"id\");",
              "        pm.expect(node).to.have.property(\"content\");",
              "        pm.expect(node).to.have.property(\"title\");",
              "        pm.expect(node).to.have.property(\"parent\");",
              "        pm.expect(node).to.have.property(\"children\");",
              "        pm.expect(node).to.have.property(\"created_at\");",
              "        ",
              "        // Validar tipos de datos",
              "        pm.expect(node.id).to.be.a(\"number\").and.to.be.greaterThan(0);",
              "        pm.expect(node.content).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "        pm.expect(node.title).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "        pm.expect(node.children).to.be.an(\"array\");",
              "        pm.expect(node.created_at).to.be.a(\"string\");",
              "        ",
              "        // Todos los nodos en /api/nodes/ deben ser raÃ­z",
              "        pm.expect(node.parent).to.be.null;",
              "    });",
              "    console.log(`âœ“ All ${responseData.length} nodes have correct structure`);",
              "});",
              "",
              "// 7. Check depth behavior",
              "if (hasDepthParam) {",
              "    const depthValue = pm.environment.get(\"requested_depth\") || \"1\";",
              "    console.log(`\\nðŸ” Testing depth=${depthValue} behavior:`);",
              "    ",
              "    if (depthValue === \"0\") {",
              "        pm.test(\"Depth=0: No children should be shown\", function () {",
              "            const nodesWithChildren = responseData.filter(node => node.children.length > 0);",
              "            pm.expect(nodesWithChildren.length).to.equal(0, ",
              "                `Found ${nodesWithChildren.length} nodes with children (should be 0)`);",
              "        });",
              "    } ",
              "    else if (depthValue === \"1\") {",
              "        pm.test(\"Depth=1: Only immediate children, no grandchildren\", function () {",
              "            let violations = 0;",
              "            ",
              "            responseData.forEach((node) => {",
              "                if (node.children.length > 0) {",
              "                    node.children.forEach((child) => {",
              "                        // Cada hijo debe tener array de hijos vacÃ­o",
              "                        if (child.children && child.children.length > 0) {",
              "                            violations++;",
              "                        }",
              "                    });",
              "                }",
              "            });",
              "            ",
              "            pm.expect(violations).to.equal(0,",
              "                `Found ${violations} children that have their own children (violates depth=1)`);",
              "            ",
              "            if (violations === 0) {",
              "                console.log(`âœ“ Depth=1 constraint verified - no grandchildren found`);",
              "            }",
              "        });",
              "    }",
              "    else {",
              "        console.log(`Depth=${depthValue}: Testing nested structure`);",
              "        // Para depth > 1, verificamos que la estructura sea consistente",
              "        pm.test(`Depth=${depthValue} structure is consistent`, function () {",
              "            responseData.forEach(node => {",
              "                pm.expect(node.children).to.be.an(\"array\");",
              "            });",
              "        });",
              "    }",
              "} else {",
              "    console.log(\"\\nâš  No depth parameter - testing default behavior\");",
              "}",
              "",
              "// 8. Validate specific fields",
              "pm.test(\"Title fields are valid (num2words)\", function () {",
              "    let invalidTitles = 0;",
              "    ",
              "    responseData.slice(0, 5).forEach((node) => { // Revisar primeros 5 nodos",
              "        const title = node.title;",
              "        // No debe ser solo nÃºmeros",
              "        const isOnlyNumbers = /^\\d+$/.test(title);",
              "        if (isOnlyNumbers) {",
              "            invalidTitles++;",
              "            console.log(`âš  Node ${node.id} has numeric title: \"${title}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(invalidTitles).to.equal(0, `Found ${invalidTitles} nodes with numeric titles`);",
              "    ",
              "    if (invalidTitles === 0) {",
              "        console.log(\"âœ“ Title validation passed - all titles are text-based\");",
              "    }",
              "});",
              "",
              "// 9. Validate dates",
              "pm.test(\"Created_at fields have correct format\", function () {",
              "    let invalidDates = 0;",
              "    ",
              "    responseData.forEach((node) => {",
              "        const datePattern = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "        if (!datePattern.test(node.created_at)) {",
              "            invalidDates++;",
              "            console.log(`âš  Node ${node.id} has invalid date format: \"${node.created_at}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(invalidDates).to.equal(0, `Found ${invalidDates} nodes with invalid date format`);",
              "    ",
              "    if (invalidDates === 0) {",
              "        console.log(\"âœ“ All dates have correct format\");",
              "    }",
              "});",
              "",
              "// 10. Verify parent-child relationships for nodes with children",
              "pm.test(\"Parent-child relationships are correct\", function () {",
              "    let incorrectRelationships = 0;",
              "    ",
              "    responseData.forEach((node) => {",
              "        if (node.children.length > 0) {",
              "            node.children.forEach((child) => {",
              "                if (child.parent !== node.id) {",
              "                    incorrectRelationships++;",
              "                    console.log(`âš  Child ${child.id} has parent ${child.parent}, expected ${node.id}`);",
              "                }",
              "            });",
              "        }",
              "    });",
              "    ",
              "    pm.expect(incorrectRelationships).to.equal(0,",
              "        `Found ${incorrectRelationships} incorrect parent-child relationships`);",
              "    ",
              "    if (incorrectRelationships === 0) {",
              "        console.log(\"âœ“ All parent-child relationships are correct\");",
              "    }",
              "});",
              "",
              "// 11. Show statistics",
              "console.log(`\\nðŸ“Š RESPONSE STATISTICS:`);",
              "console.log(`Total nodes: ${responseData.length}`);",
              "",
              "const nodesWithChildren = responseData.filter(node => node.children.length > 0).length;",
              "console.log(`Nodes with children: ${nodesWithChildren}`);",
              "",
              "const totalChildren = responseData.reduce((sum, node) => sum + node.children.length, 0);",
              "console.log(`Total children: ${totalChildren}`);",
              "",
              "const avgChildrenPerNode = nodesWithChildren > 0 ? (totalChildren / nodesWithChildren).toFixed(2) : 0;",
              "console.log(`Average children per node (with children): ${avgChildrenPerNode}`);",
              "",
              "// 12. Performance check",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    const time = pm.response.responseTime;",
              "    console.log(`\\nâ± Performance: ${time}ms`);",
              "    ",
              "    if (time > 1000) {",
              "        console.log(\"âš  Response time > 1 second\");",
              "    }",
              "});",
              "",
              "// 13. Response headers",
              "pm.test(\"Response headers are valid\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ“ Content-Type: ${contentType}`);",
              "    ",
              "    // Check cache headers if present",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    if (cacheControl) {",
              "        console.log(`âœ“ Cache-Control: ${cacheControl}`);",
              "    }",
              "});",
              "",
              "// 14. Save useful data for future tests",
              "if (responseData.length > 0) {",
              "    // Save first node",
              "    const firstNode = responseData[0];",
              "    pm.environment.set(\"first_root_node_id\", firstNode.id.toString());",
              "    pm.environment.set(\"first_root_node_content\", firstNode.content);",
              "    console.log(`âœ“ First node saved: ID ${firstNode.id}`);",
              "    ",
              "    // Find and save a node with children",
              "    const nodeWithChildren = responseData.find(node => node.children.length > 0);",
              "    if (nodeWithChildren) {",
              "        pm.environment.set(\"node_with_children_id\", nodeWithChildren.id.toString());",
              "        pm.environment.set(\"node_with_children_content\", nodeWithChildren.content);",
              "        pm.environment.set(\"node_with_children_child_count\", nodeWithChildren.children.length.toString());",
              "        ",
              "        // Save first child ID",
              "        if (nodeWithChildren.children.length > 0) {",
              "            const firstChild = nodeWithChildren.children[0];",
              "            pm.environment.set(\"first_child_id\", firstChild.id.toString());",
              "            pm.environment.set(\"first_child_content\", firstChild.content);",
              "            console.log(`âœ“ Node with children saved: ID ${nodeWithChildren.id} (${nodeWithChildren.children.length} children)`);",
              "        }",
              "    }",
              "    ",
              "    // Save all node IDs for potential future use",
              "    const allNodeIds = responseData.map(node => node.id);",
              "    pm.environment.set(\"all_root_node_ids\", JSON.stringify(allNodeIds));",
              "}",
              "",
              "// 15. Final summary",
              "console.log(`\\nâœ… TEST SUMMARY:`);",
              "console.log(`   Request: ${pm.request.method} ${url.split('?')[0]}`);",
              "console.log(`   Parameters: ${hasDepthParam ? 'depth=' + (pm.environment.get(\"requested_depth\") || \"1\") : 'none'}`);",
              "console.log(`   Response: ${responseData.length} root nodes`);",
              "console.log(`   Status: ${pm.response.code} OK`);",
              "console.log(`   Time: ${pm.response.responseTime}ms`);",
              "console.log(`   Depth validation: ${hasDepthParam ? 'PASSED' : 'NOT TESTED'}`);",
              "",
              "console.log(\"\\nðŸŽ¯ Test completed successfully!\");",
              "",
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/?depth=3",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ],
          "query": [
            {
              "key": "depth",
              "value": "3"
            }
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Esp",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Get Nodes with Spanish Language Header",
              "// ============================================",
              "",
              "console.log(\"=== Test: Get Nodes with Spanish Language (Accept-Language: es) ===\");",
              "",
              "// 1. Verify Accept-Language header",
              "const acceptLanguageHeader = pm.request.headers.get(\"Accept-Language\");",
              "pm.test(\"Accept-Language header is set to Spanish (es)\", function () {",
              "    pm.expect(acceptLanguageHeader).to.exist;",
              "    pm.expect(acceptLanguageHeader.toLowerCase()).to.include(\"es\");",
              "    console.log(`âœ“ Accept-Language: ${acceptLanguageHeader}`);",
              "});",
              "",
              "// 2. Status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 3. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON array\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "if (!responseData || responseData.length === 0) {",
              "    console.log(\"âš  Response is empty\");",
              "    return;",
              "}",
              "",
              "console.log(`âœ“ Found ${responseData.length} nodes`);",
              "",
              "// 4. Tolerancia para variaciones de num2words",
              "const spanishVariations = {",
              "    // Variaciones comunes de num2words",
              "    \"veintisÃ©is\": [\"veintiseis\", \"veinti seis\", \"veinti-seis\"],",
              "    \"veintisiete\": [\"veintisiete\", \"veinti siete\", \"veinti-siete\"],",
              "    \"veintiocho\": [\"veintiocho\", \"veinti ocho\", \"veinti-ocho\"],",
              "    \"veintinueve\": [\"veintinueve\", \"veinti nueve\", \"veinti-nueve\"],",
              "    \"treinta y uno\": [\"treinta y uno\", \"treinta y uno\"],",
              "    \"cuarenta y uno\": [\"cuarenta y uno\", \"cuarenta y uno\"],",
              "    \"cincuenta y uno\": [\"cincuenta y uno\", \"cincuenta y uno\"]",
              "};",
              "",
              "// 5. FunciÃ³n para normalizar tÃ­tulos",
              "function normalizeTitle(title) {",
              "    if (!title) return \"\";",
              "    ",
              "    let normalized = title.toLowerCase().trim();",
              "    ",
              "    // Remover acentos y caracteres especiales",
              "    normalized = normalized",
              "        .replace(/Ã¡/g, 'a').replace(/Ã©/g, 'e').replace(/Ã­/g, 'i')",
              "        .replace(/Ã³/g, 'o').replace(/Ãº/g, 'u').replace(/Ã¼/g, 'u')",
              "        .replace(/Ã±/g, 'n')",
              "        .replace(/[^a-z0-9\\s]/g, '')  // Remover otros caracteres especiales",
              "        .replace(/\\s+/g, ' ')         // Normalizar espacios",
              "        .trim();",
              "    ",
              "    return normalized;",
              "}",
              "",
              "// 6. Tomar los primeros nodos para verificar",
              "const sampleSize = Math.min(8, responseData.length);",
              "const sampleNodes = responseData.slice(0, sampleSize);",
              "",
              "console.log(`\\nðŸ” VERIFICANDO TÃTULOS EN ESPAÃ‘OL (${sampleSize} nodos):`);",
              "",
              "// 7. TEST MEJORADO: Verificar que los tÃ­tulos NO estÃ¡n en inglÃ©s",
              "pm.test(\"Titles are not in English (confirmation they're in Spanish)\", function () {",
              "    const englishNumbers = {",
              "        1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\",",
              "        6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\", 10: \"ten\"",
              "    };",
              "    ",
              "    let englishTitlesFound = 0;",
              "    ",
              "    sampleNodes.forEach((node) => {",
              "        const normalizedTitle = normalizeTitle(node.title);",
              "        const expectedEnglish = englishNumbers[node.id];",
              "        ",
              "        if (expectedEnglish && normalizedTitle === expectedEnglish) {",
              "            englishTitlesFound++;",
              "            console.log(`âŒ Node ${node.id}: Title is in English - \"${node.title}\"`);",
              "        }",
              "    });",
              "    ",
              "    // No deberÃ­amos encontrar tÃ­tulos en inglÃ©s",
              "    pm.expect(englishTitlesFound).to.equal(0,",
              "        `Found ${englishTitlesFound} titles in English with Accept-Language: es`);",
              "    ",
              "    console.log(`âœ“ No titles in English found`);",
              "});",
              "",
              "// 8. TEST: Verificar que los tÃ­tulos son palabras (no nÃºmeros)",
              "pm.test(\"Titles are word representations (not digits)\", function () {",
              "    let digitTitles = 0;",
              "    ",
              "    sampleNodes.forEach((node) => {",
              "        // Verificar que el tÃ­tulo NO es solo dÃ­gitos",
              "        if (/^\\d+$/.test(node.title.trim())) {",
              "            digitTitles++;",
              "            console.log(`âŒ Node ${node.id}: Title is digits - \"${node.title}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(digitTitles).to.equal(0,",
              "        `Found ${digitTitles} titles that are digits`);",
              "    ",
              "    console.log(`âœ“ All titles are word representations`);",
              "});",
              "",
              "// 9. TEST: Verificar que los tÃ­tulos son diferentes del contenido",
              "pm.test(\"Titles are different from content\", function () {",
              "    let sameAsContent = 0;",
              "    ",
              "    sampleNodes.forEach((node) => {",
              "        const normalizedTitle = normalizeTitle(node.title);",
              "        const normalizedContent = normalizeTitle(node.content);",
              "        ",
              "        if (normalizedTitle === normalizedContent) {",
              "            sameAsContent++;",
              "            console.log(`âš  Node ${node.id}: Title same as content - \"${node.title}\"`);",
              "        }",
              "    });",
              "    ",
              "    pm.expect(sameAsContent).to.be.lessThan(3,",
              "        `Found ${sameAsContent} titles identical to content`);",
              "    ",
              "    if (sameAsContent === 0) {",
              "        console.log(`âœ“ All titles differ from content`);",
              "    }",
              "});",
              "",
              "// 10. TEST: Verificar estructura del tÃ­tulo espaÃ±ol",
              "pm.test(\"Spanish titles have Spanish language characteristics\", function () {",
              "    let spanishCharacteristics = 0;",
              "    const totalToCheck = sampleSize;",
              "    ",
              "    // CaracterÃ­sticas comunes del espaÃ±ol",
              "    const spanishPatterns = [",
              "        / y /,                    // \"y\" para unir nÃºmeros (treinta y uno)",
              "        /cientos?/,               // \"cientos\"",
              "        /millones?/,              // \"millones\"",
              "        /(uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)/i,",
              "        /(veinti|treinta|cuarenta|cincuenta|sesenta|setenta|ochenta|noventa)/i",
              "    ];",
              "    ",
              "    sampleNodes.forEach((node) => {",
              "        const title = node.title.toLowerCase();",
              "        ",
              "        // Verificar al menos una caracterÃ­stica del espaÃ±ol",
              "        const hasSpanishChar = spanishPatterns.some(pattern => pattern.test(title));",
              "        ",
              "        if (hasSpanishChar) {",
              "            spanishCharacteristics++;",
              "        } else {",
              "            console.log(`âš  Node ${node.id}: May not look Spanish - \"${node.title}\"`);",
              "        }",
              "    });",
              "    ",
              "    // Al menos 70% deberÃ­a tener caracterÃ­sticas espaÃ±olas",
              "    const minRequired = Math.floor(totalToCheck * 0.7);",
              "    pm.expect(spanishCharacteristics).to.be.at.least(minRequired,",
              "        `Only ${spanishCharacteristics}/${totalToCheck} titles show Spanish characteristics`);",
              "    ",
              "    console.log(`âœ“ ${spanishCharacteristics}/${totalToCheck} titles show Spanish characteristics`);",
              "});",
              "",
              "// 11. Mostrar ejemplos para debug",
              "console.log(\"\\nðŸ“ EJEMPLOS DE TÃTULOS:\");",
              "sampleNodes.forEach((node, index) => {",
              "    console.log(`${index + 1}. ID: ${node.id} â†’ TÃ­tulo: \"${node.title}\"`);",
              "});",
              "",
              "// 12. Guardar para comparaciÃ³n con otros idiomas",
              "if (sampleNodes.length > 0) {",
              "    const exampleNode = sampleNodes[0];",
              "    pm.environment.set(\"spanish_title_example\", exampleNode.title);",
              "    pm.environment.set(\"spanish_node_id\", exampleNode.id.toString());",
              "    console.log(`\\nðŸ’¾ Saved example: ID ${exampleNode.id} â†’ \"${exampleNode.title}\"`);",
              "}",
              "",
              "// 13. Headers de respuesta",
              "pm.test(\"Response headers are appropriate\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    if (contentType) {",
              "        pm.expect(contentType).to.include(\"application/json\");",
              "    }",
              "    console.log(`âœ“ Content-Type: ${contentType || 'Not specified'}`);",
              "});",
              "",
              "// 14. Performance",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(3000);",
              "    console.log(`\\nâ± Response time: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "console.log(\"\\nâœ… TEST DE ESPAÃ‘OL COMPLETADO\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [
          {
            "key": "Accept-Language",
            "value": "es",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{LOCAL}}/nodes/?depth=1",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ],
          "query": [
            {
              "key": "depth",
              "value": "1"
            }
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_French",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Get Nodes with French Language Header",
              "// Endpoint: GET /api/nodes/?depth=1",
              "// Header: Accept-Language: fr (French)",
              "// ============================================",
              "",
              "console.log(\"=== Test: Get Nodes with French Language (Accept-Language: fr) ===\");",
              "",
              "// 1. Verify Accept-Language header is set to French",
              "const acceptLanguageHeader = pm.request.headers.get(\"Accept-Language\");",
              "pm.test(\"Accept-Language header is set to French (fr)\", function () {",
              "    pm.expect(acceptLanguageHeader).to.exist;",
              "    pm.expect(acceptLanguageHeader).to.include(\"fr\");",
              "    console.log(`âœ“ Accept-Language header: ${acceptLanguageHeader}`);",
              "});",
              "",
              "// 2. Get the URL",
              "const url = pm.request.url.toString();",
              "console.log(`Request URL: ${url}`);",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON array\", function () {",
              "        pm.expect(responseData).to.be.an(\"array\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Check if response is empty",
              "if (!responseData || responseData.length === 0) {",
              "    console.log(\"âš  Response is empty array - no nodes to test\");",
              "    return;",
              "}",
              "",
              "console.log(`âœ“ Response contains ${responseData.length} nodes`);",
              "",
              "// 6. Take first few nodes to verify French titles",
              "const nodesToCheck = responseData.slice(0, Math.min(5, responseData.length));",
              "",
              "console.log(\"\\nðŸ” VERIFYING FRENCH TITLES:\");",
              "console.log(\"Expected French number words:\");",
              "",
              "// Expected French number words for IDs 1-50",
              "const frenchNumbers = {",
              "    1: \"un\", 2: \"deux\", 3: \"trois\", 4: \"quatre\", 5: \"cinq\",",
              "    6: \"six\", 7: \"sept\", 8: \"huit\", 9: \"neuf\", 10: \"dix\",",
              "    11: \"onze\", 12: \"douze\", 13: \"treize\", 14: \"quatorze\", 15: \"quinze\",",
              "    16: \"seize\", 17: \"dix-sept\", 18: \"dix-huit\", 19: \"dix-neuf\", 20: \"vingt\",",
              "    21: \"vingt et un\", 22: \"vingt-deux\", 23: \"vingt-trois\", 24: \"vingt-quatre\", 25: \"vingt-cinq\",",
              "    26: \"vingt-six\", 27: \"vingt-sept\", 28: \"vingt-huit\", 29: \"vingt-neuf\", 30: \"trente\",",
              "    31: \"trente et un\", 32: \"trente-deux\", 33: \"trente-trois\", 34: \"trente-quatre\", 35: \"trente-cinq\",",
              "    36: \"trente-six\", 37: \"trente-sept\", 38: \"trente-huit\", 39: \"trente-neuf\", 40: \"quarante\",",
              "    41: \"quarante et un\", 42: \"quarante-deux\", 43: \"quarante-trois\", 44: \"quarante-quatre\", 45: \"quarante-cinq\",",
              "    46: \"quarante-six\", 47: \"quarante-sept\", 48: \"quarante-huit\", 49: \"quarante-neuf\", 50: \"cinquante\"",
              "};",
              "",
              "// 7. CRITICAL: Verify French titles",
              "pm.test(\"Titles are in French (case-insensitive comparison)\", function () {",
              "    let correctFrenchTitles = 0;",
              "    let incorrectTitles = 0;",
              "    ",
              "    nodesToCheck.forEach((node, index) => {",
              "        const nodeId = node.id;",
              "        const expectedFrench = frenchNumbers[nodeId];",
              "        const actualTitle = node.title.toLowerCase().trim();",
              "        ",
              "        console.log(`Node ID ${nodeId}:`);",
              "        console.log(`  Expected (fr): \"${expectedFrench}\"`);",
              "        console.log(`  Actual: \"${actualTitle}\"`);",
              "        ",
              "        if (expectedFrench && actualTitle === expectedFrench) {",
              "            correctFrenchTitles++;",
              "            console.log(`  âœ… Correct French title`);",
              "        } else if (expectedFrench) {",
              "            incorrectTitles++;",
              "            console.log(`  âŒ Expected \"${expectedFrench}\", got \"${actualTitle}\"`);",
              "            ",
              "            // Check common alternatives or fallbacks",
              "            const checkSimilarity = (expected, actual) => {",
              "                // Remove hyphens and spaces for comparison",
              "                const cleanExpected = expected.replace(/[- ]/g, '');",
              "                const cleanActual = actual.replace(/[- ]/g, '');",
              "                return cleanExpected === cleanActual;",
              "            };",
              "            ",
              "            if (checkSimilarity(expectedFrench, actualTitle)) {",
              "                console.log(`  âš  Similar (formatting differences): \"${expectedFrench}\" vs \"${actualTitle}\"`);",
              "                correctFrenchTitles++; // Count as correct despite formatting",
              "            } else {",
              "                // Check if it's English (common fallback)",
              "                const englishNumbers = {",
              "                    1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\",",
              "                    6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\", 10: \"ten\"",
              "                };",
              "                const expectedEnglish = englishNumbers[nodeId];",
              "                if (expectedEnglish && actualTitle === expectedEnglish) {",
              "                    console.log(`  âš  Title is in English (fallback language)`);",
              "                }",
              "                // Check if it's Spanish (another common language)",
              "                const spanishNumbers = {",
              "                    1: \"uno\", 2: \"dos\", 3: \"tres\", 4: \"cuatro\", 5: \"cinco\"",
              "                };",
              "                const expectedSpanish = spanishNumbers[nodeId];",
              "                if (expectedSpanish && actualTitle === expectedSpanish) {",
              "                    console.log(`  âš  Title is in Spanish (wrong language)`);",
              "                }",
              "            }",
              "        } else {",
              "            console.log(`  âš  No expected French translation for ID ${nodeId}`);",
              "        }",
              "    });",
              "    ",
              "    // Allow some margin for num2words library variations and formatting",
              "    const minRequired = Math.ceil(nodesToCheck.length * 0.7); // At least 70%",
              "    pm.expect(correctFrenchTitles).to.be.at.least(minRequired,",
              "        `Only ${correctFrenchTitles}/${nodesToCheck.length} nodes have correct French titles`);",
              "    ",
              "    console.log(`\\nðŸ“Š French Title Accuracy: ${correctFrenchTitles}/${nodesToCheck.length} correct`);",
              "});",
              "",
              "// 8. Verify all nodes have consistent language",
              "pm.test(\"All checked nodes have French-style titles\", function () {",
              "    // Common French words to check for",
              "    const frenchWords = [\"un\", \"deux\", \"trois\", \"quatre\", \"cinq\", \"six\", \"sept\", \"huit\", \"neuf\", \"dix\"];",
              "    let frenchStyleCount = 0;",
              "    ",
              "    nodesToCheck.forEach((node) => {",
              "        const title = node.title.toLowerCase();",
              "        // Check if title contains any French number word",
              "        const hasFrenchWord = frenchWords.some(word => title.includes(word));",
              "        ",
              "        if (hasFrenchWord) {",
              "            frenchStyleCount++;",
              "        } else {",
              "            console.log(`âš  Node ${node.id} title \"${title}\" doesn't appear French`);",
              "        }",
              "    });",
              "    ",
              "    // Most should appear French",
              "    pm.expect(frenchStyleCount).to.be.at.least(Math.ceil(nodesToCheck.length * 0.6),",
              "        `Only ${frenchStyleCount}/${nodesToCheck.length} nodes appear to have French titles`);",
              "    ",
              "    console.log(`âœ“ ${frenchStyleCount}/${nodesToCheck.length} nodes appear to have French titles`);",
              "});",
              "",
              "// 9. Verify title field exists and is valid",
              "pm.test(\"All nodes have valid title field\", function () {",
              "    responseData.forEach((node, index) => {",
              "        pm.expect(node).to.have.property(\"title\");",
              "        pm.expect(node.title).to.be.a(\"string\");",
              "        pm.expect(node.title.trim().length).to.be.greaterThan(0,",
              "            `Node ${node.id} has empty title`);",
              "    });",
              "    console.log(\"âœ“ All nodes have valid title field\");",
              "});",
              "",
              "// 10. Compare with other language versions if available",
              "const previousEnglishTitle = pm.environment.get(\"english_example_title\");",
              "const previousSpanishTitle = pm.environment.get(\"spanish_example_title\");",
              "",
              "if (responseData.length > 0) {",
              "    const testNodeId = pm.environment.get(\"test_node_id\") || responseData[0].id.toString();",
              "    const frenchNode = responseData.find(node => node.id.toString() === testNodeId);",
              "    ",
              "    if (frenchNode && (previousEnglishTitle || previousSpanishTitle)) {",
              "        console.log(\"\\nðŸŒ MULTI-LANGUAGE COMPARISON:\");",
              "        console.log(`Node ID: ${frenchNode.id}`);",
              "        console.log(`Content: \"${frenchNode.content}\"`);",
              "        ",
              "        if (previousEnglishTitle) {",
              "            console.log(`English: \"${previousEnglishTitle}\"`);",
              "            console.log(`French:  \"${frenchNode.title}\"`);",
              "            ",
              "            pm.test(\"French title differs from English title\", function () {",
              "                pm.expect(frenchNode.title.toLowerCase()).to.not.equal(previousEnglishTitle.toLowerCase(),",
              "                    `French title should differ from English`);",
              "            });",
              "        }",
              "        ",
              "        if (previousSpanishTitle) {",
              "            console.log(`Spanish: \"${previousSpanishTitle}\"`);",
              "            ",
              "            pm.test(\"French title differs from Spanish title\", function () {",
              "                pm.expect(frenchNode.title.toLowerCase()).to.not.equal(previousSpanishTitle.toLowerCase(),",
              "                    `French title should differ from Spanish`);",
              "            });",
              "        }",
              "    }",
              "}",
              "",
              "// 11. Check for Content-Language header",
              "pm.test(\"Response may include French Content-Language header\", function () {",
              "    const contentLanguage = pm.response.headers.get(\"Content-Language\");",
              "    if (contentLanguage) {",
              "        console.log(`âœ“ Content-Language header: ${contentLanguage}`);",
              "        // Should indicate French",
              "        pm.expect(contentLanguage.toLowerCase()).to.include(\"fr\");",
              "    } else {",
              "        console.log(\"âš  No Content-Language header in response\");",
              "    }",
              "});",
              "",
              "// 12. Save French examples for future tests",
              "if (responseData.length > 0) {",
              "    console.log(\"\\nðŸ“ FRENCH TITLE EXAMPLES:\");",
              "    const exampleNodes = responseData.slice(0, 3);",
              "    ",
              "    exampleNodes.forEach((node, index) => {",
              "        console.log(`${index + 1}. ID: ${node.id}`);",
              "        console.log(`   Content: \"${node.content}\"`);",
              "        console.log(`   Title (fr): \"${node.title}\"`);",
              "        console.log(`   Parent: ${node.parent === null ? \"Racine\" : node.parent}`);",
              "    });",
              "    ",
              "    // Save French examples",
              "    pm.environment.set(\"french_example_id\", exampleNodes[0].id.toString());",
              "    pm.environment.set(\"french_example_title\", exampleNodes[0].title);",
              "    pm.environment.set(\"french_example_content\", exampleNodes[0].content);",
              "    ",
              "    // Save a test node ID for cross-language comparison",
              "    if (!pm.environment.get(\"test_node_id\")) {",
              "        pm.environment.set(\"test_node_id\", exampleNodes[0].id.toString());",
              "        console.log(`âœ“ Set test_node_id: ${exampleNodes[0].id} for cross-language tests`);",
              "    }",
              "}",
              "",
              "// 13. Performance check",
              "pm.test(\"Response time with French language header is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    const time = pm.response.responseTime;",
              "    console.log(`\\nâ± Response time: ${time}ms`);",
              "    ",
              "    if (time > 1000) {",
              "        console.log(\"âš  Response time > 1 second\");",
              "    }",
              "});",
              "",
              "// 14. Test language fallback scenarios",
              "pm.test(\"French language processing test\", function () {",
              "    // Test that at least some nodes have non-English titles",
              "    const englishWords = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"];",
              "    let englishTitleCount = 0;",
              "    ",
              "    nodesToCheck.forEach(node => {",
              "        const title = node.title.toLowerCase();",
              "        if (englishWords.some(word => title === word)) {",
              "            englishTitleCount++;",
              "        }",
              "    });",
              "    ",
              "    // Should not have many English titles when French is requested",
              "    pm.expect(englishTitleCount).to.be.lessThan(nodesToCheck.length / 2,",
              "        `Too many English titles (${englishTitleCount}) when French was requested`);",
              "    ",
              "    console.log(`âœ“ Only ${englishTitleCount}/${nodesToCheck.length} nodes have English titles`);",
              "});",
              "",
              "// 15. Final summary",
              "console.log(`\\nâœ… FRENCH LANGUAGE TEST SUMMARY:`);",
              "console.log(`   Request headers: Accept-Language: ${acceptLanguageHeader}`);",
              "console.log(`   Tested nodes: ${nodesToCheck.length} of ${responseData.length}`);",
              "console.log(`   Response status: ${pm.response.code}`);",
              "console.log(`   Response time: ${pm.response.responseTime}ms`);",
              "",
              "console.log(\"\\nðŸŽ¯ French language test completed!\");",
              "console.log(\"\\nðŸ’¡ TIP: To test multiple languages, run these tests in sequence:\");",
              "console.log(\"1. Accept-Language: en (English)\");",
              "console.log(\"2. Accept-Language: es (Spanish)\");  ",
              "console.log(\"3. Accept-Language: fr (French)\");",
              "console.log(\"4. Accept-Language: de (German)\");",
              "console.log(\"5. Accept-Language: it (Italian)\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [
          {
            "key": "Accept-Language",
            "value": "fr",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{LOCAL}}/nodes/?depth=1",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ],
          "query": [
            {
              "key": "depth",
              "value": "1"
            }
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_De",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Get Nodes with German Language Header - CORREGIDO",
              "// ============================================",
              "",
              "console.log(\"=== Test: Get Nodes with German Language (Accept-Language: de) ===\");",
              "",
              "// 1. Verificar header",
              "const acceptLanguageHeader = pm.request.headers.get(\"Accept-Language\");",
              "pm.test(\"Accept-Language header is set to German (de)\", function () {",
              "    pm.expect(acceptLanguageHeader).to.exist.and.to.include(\"de\");",
              "    console.log(`âœ“ Accept-Language: ${acceptLanguageHeader}`);",
              "});",
              "",
              "// 2. Status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 3. Parse response",
              "const responseData = pm.response.json();",
              "pm.test(\"Response is valid JSON array\", function () {",
              "    pm.expect(responseData).to.be.an(\"array\");",
              "});",
              "",
              "if (!responseData || responseData.length === 0) {",
              "    console.log(\"âš  No nodes to test\");",
              "    return;",
              "}",
              "",
              "console.log(`âœ“ Found ${responseData.length} nodes`);",
              "",
              "// 4. Tomar nodos con IDs pequeÃ±os para verificar (mÃ¡s confiables)",
              "const smallIdNodes = responseData.filter(node => node.id <= 20).slice(0, 5);",
              "const nodesToCheck = smallIdNodes.length > 0 ? smallIdNodes : responseData.slice(0, 3);",
              "",
              "console.log(`\\nðŸ” Verificando ${nodesToCheck.length} nodos:`);",
              "",
              "// 5. Diccionario mejorado de nÃºmeros alemanes",
              "const germanNumbers = {",
              "    1: \"eins\", 2: \"zwei\", 3: \"drei\", 4: \"vier\", 5: \"fÃ¼nf\",",
              "    6: \"sechs\", 7: \"sieben\", 8: \"acht\", 9: \"neun\", 10: \"zehn\",",
              "    11: \"elf\", 12: \"zwÃ¶lf\", 13: \"dreizehn\", 14: \"vierzehn\", 15: \"fÃ¼nfzehn\",",
              "    16: \"sechzehn\", 17: \"siebzehn\", 18: \"achtzehn\", 19: \"neunzehn\", 20: \"zwanzig\",",
              "    21: \"einundzwanzig\", 22: \"zweiundzwanzig\", 23: \"dreiundzwanzig\", 24: \"vierundzwanzig\", 25: \"fÃ¼nfundzwanzig\",",
              "    26: \"sechsundzwanzig\", 27: \"siebenundzwanzig\", 28: \"achtundzwanzig\", 29: \"neunundzwanzig\", 30: \"dreiÃŸig\",",
              "    31: \"einunddreiÃŸig\", 32: \"zweiunddreiÃŸig\", 33: \"dreiunddreiÃŸig\", 34: \"vierunddreiÃŸig\", 35: \"fÃ¼nfunddreiÃŸig\"",
              "};",
              "",
              "// 6. TEST PRINCIPAL MEJORADO: Verificar caracterÃ­sticas alemanas",
              "pm.test(\"Titles show German language characteristics\", function () {",
              "    let germanLikeTitles = 0;",
              "    ",
              "    nodesToCheck.forEach(node => {",
              "        const title = node.title.toLowerCase();",
              "        console.log(`ID ${node.id}: \"${title}\"`);",
              "        ",
              "        // CaracterÃ­sticas del alemÃ¡n:",
              "        const hasGermanFeatures = ",
              "            title.includes(\"und\") ||           // \"einundzwanzig\", \"zweiunddreiÃŸig\"",
              "            title.includes(\"zig\") ||           // \"zwanzig\", \"dreiÃŸig\"",
              "            title.includes(\"zehn\") ||          // \"zehn\", \"dreizehn\"",
              "            title.includes(\"eins\") ||",
              "            title.includes(\"zwei\") ||",
              "            title.includes(\"drei\") ||",
              "            title.includes(\"vier\") ||",
              "            title.includes(\"fÃ¼nf\") ||",
              "            title.includes(\"sechs\") ||",
              "            title.includes(\"sieben\") ||",
              "            title.includes(\"acht\") ||",
              "            title.includes(\"neun\");",
              "        ",
              "        if (hasGermanFeatures) {",
              "            germanLikeTitles++;",
              "            console.log(`  âœ… Parece alemÃ¡n`);",
              "        } else {",
              "            console.log(`  âš  No parece alemÃ¡n`);",
              "        }",
              "    });",
              "    ",
              "    // DeberÃ­a tener al menos 70% de caracterÃ­sticas alemanas",
              "    const minRequired = Math.floor(nodesToCheck.length * 0.7);",
              "    pm.expect(germanLikeTitles).to.be.at.least(minRequired,",
              "        `Solo ${germanLikeTitles}/${nodesToCheck.length} nodos parecen tener tÃ­tulos alemanes`);",
              "    ",
              "    console.log(`âœ“ ${germanLikeTitles}/${nodesToCheck.length} nodos con caracterÃ­sticas alemanas`);",
              "});",
              "",
              "// 7. TEST: Verificar que NO estÃ¡n en inglÃ©s",
              "pm.test(\"Titles are not in English (confirming German language)\", function () {",
              "    const englishNumbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"];",
              "    let englishTitles = 0;",
              "    ",
              "    nodesToCheck.forEach(node => {",
              "        const title = node.title.toLowerCase();",
              "        if (englishNumbers.includes(title)) {",
              "            englishTitles++;",
              "            console.log(`âŒ ID ${node.id}: TÃ­tulo en inglÃ©s - \"${title}\"`);",
              "        }",
              "    });",
              "    ",
              "    // No deberÃ­amos encontrar tÃ­tulos en inglÃ©s con header 'de'",
              "    pm.expect(englishTitles).to.equal(0,",
              "        `Encontrados ${englishTitles} tÃ­tulos en inglÃ©s con Accept-Language: de`);",
              "    ",
              "    console.log(`âœ“ No se encontraron tÃ­tulos en inglÃ©s`);",
              "});",
              "",
              "// 8. TEST: Verificar IDs pequeÃ±os especÃ­ficos (si existen)",
              "if (nodesToCheck.some(node => node.id <= 10)) {",
              "    pm.test(\"Small number IDs (1-10) have correct German titles\", function () {",
              "        const smallNumberTests = nodesToCheck.filter(node => node.id <= 10);",
              "        let correctCount = 0;",
              "        ",
              "        smallNumberTests.forEach(node => {",
              "            const expected = germanNumbers[node.id];",
              "            const actual = node.title.toLowerCase();",
              "            ",
              "            if (expected && actual === expected) {",
              "                correctCount++;",
              "                console.log(`âœ… ID ${node.id}: \"${actual}\" = \"${expected}\"`);",
              "            } else if (expected) {",
              "                console.log(`âš  ID ${node.id}: \"${actual}\" â‰  \"${expected}\"`);",
              "            }",
              "        });",
              "        ",
              "        // Si hay nodos pequeÃ±os, la mayorÃ­a deberÃ­an ser correctos",
              "        if (smallNumberTests.length > 0) {",
              "            const required = Math.ceil(smallNumberTests.length * 0.8);",
              "            pm.expect(correctCount).to.be.at.least(required,",
              "                `Solo ${correctCount}/${smallNumberTests.length} nÃºmeros pequeÃ±os son correctos`);",
              "        }",
              "    });",
              "}",
              "",
              "// 9. TEST: Todos los nodos tienen tÃ­tulo",
              "pm.test(\"All nodes have title field\", function () {",
              "    responseData.forEach(node => {",
              "        pm.expect(node).to.have.property(\"title\");",
              "        pm.expect(node.title).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
              "    });",
              "    console.log(`âœ“ Todos los ${responseData.length} nodos tienen tÃ­tulo`);",
              "});",
              "",
              "// 10. Guardar ejemplos",
              "if (responseData.length > 0) {",
              "    console.log(\"\\nðŸ“ EJEMPLOS DE TÃTULOS ALEMANES:\");",
              "    const examples = responseData.slice(0, 5).map(node => `ID ${node.id}: \"${node.title}\"`);",
              "    examples.forEach(example => console.log(example));",
              "    ",
              "    pm.environment.set(\"german_examples\", JSON.stringify(examples));",
              "}",
              "",
              "console.log(\"\\nâœ… TEST DE ALEMÃN COMPLETADO\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [
          {
            "key": "Accept-Language",
            "value": "de",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{LOCAL}}/nodes/?depth=1",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ],
          "query": [
            {
              "key": "depth",
              "value": "1"
            }
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_NY_Time",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Time Zone Difference for Node 1 (NY vs Madrid)",
              "// Endpoint: GET /api/nodes/1/",
              "// Tests: Time-Zone: Europe/Madrid vs Time-Zone: America/New_York",
              "// ============================================",
              "",
              "console.log(\"=== Test: Time Zone Difference for Node 1 ===\");",
              "",
              "// 1. Get current timezone being tested",
              "const currentTimeZone = pm.request.headers.get(\"Time-Zone\");",
              "pm.test(\"Time-Zone header is set\", function () {",
              "    pm.expect(currentTimeZone).to.exist;",
              "    pm.expect(currentTimeZone.trim().length).to.be.greaterThan(0);",
              "    console.log(`âœ“ Testing with Time-Zone: ${currentTimeZone}`);",
              "});",
              "",
              "// 2. Verify we're testing node 1",
              "const url = pm.request.url.toString();",
              "pm.test(\"Testing specific node 1\", function () {",
              "    pm.expect(url).to.include(\"/api/nodes/1/\");",
              "    console.log(`âœ“ Testing Node ID: 1`);",
              "});",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Verify we got node 1",
              "pm.test(\"Response is for node 1\", function () {",
              "    pm.expect(responseData.id).to.equal(1);",
              "    console.log(`âœ“ Got Node 1: \"${responseData.content}\"`);",
              "});",
              "",
              "// 6. Verify date format",
              "pm.test(\"created_at has correct format\", function () {",
              "    const datePattern = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "    pm.expect(responseData.created_at).to.match(datePattern);",
              "    console.log(`âœ“ created_at: ${responseData.created_at}`);",
              "});",
              "",
              "// 7. Parse the date for analysis",
              "const parseDateTime = (dateStr) => {",
              "    const [datePart, timePart] = dateStr.split(' ');",
              "    const [year, month, day] = datePart.split('-').map(Number);",
              "    const [hour, minute, second] = timePart.split(':').map(Number);",
              "    return {",
              "        year, month, day, hour, minute, second,",
              "        jsDate: new Date(year, month - 1, day, hour, minute, second),",
              "        timestamp: new Date(year, month - 1, day, hour, minute, second).getTime()",
              "    };",
              "};",
              "",
              "const currentDateInfo = parseDateTime(responseData.created_at);",
              "console.log(`\\nðŸ“… Current date analysis (${currentTimeZone}):`);",
              "console.log(`   Date: ${currentDateInfo.year}-${currentDateInfo.month}-${currentDateInfo.day}`);",
              "console.log(`   Time: ${currentDateInfo.hour}:${currentDateInfo.minute}:${currentDateInfo.second}`);",
              "",
              "// 8. Determine if we're in daylight saving time period",
              "const isSummerTime = (month, day) => {",
              "    // European Summer Time (Madrid): Last Sunday March to last Sunday October",
              "    // US Daylight Time (New York): Second Sunday March to first Sunday November",
              "    ",
              "    // Simple month-based approximation for test purposes",
              "    // March (3) to October (10) for Northern Hemisphere summer",
              "    return month >= 3 && month <= 10;",
              "};",
              "",
              "const currentMonth = currentDateInfo.month;",
              "const isCurrentlyDST = isSummerTime(currentMonth, currentDateInfo.day);",
              "console.log(`   Month: ${currentMonth} (${isCurrentlyDST ? 'Summer/DST season' : 'Winter/Standard season'})`);",
              "",
              "// 9. Save data based on timezone",
              "const tzKey = currentTimeZone.replace(/[\\/]/g, '_');",
              "pm.environment.set(`tz_${tzKey}_created_at`, responseData.created_at);",
              "pm.environment.set(`tz_${tzKey}_hour`, currentDateInfo.hour.toString());",
              "pm.environment.set(`tz_${tzKey}_timestamp`, currentDateInfo.timestamp.toString());",
              "pm.environment.set(`tz_${tzKey}_month`, currentMonth.toString());",
              "",
              "// 10. CRITICAL: Compare with other timezone if available",
              "const nyTZ = \"America/New_York\";",
              "const madridTZ = \"Europe/Madrid\";",
              "",
              "const nyKey = nyTZ.replace(/[\\/]/g, '_');",
              "const madridKey = madridTZ.replace(/[\\/]/g, '_');",
              "",
              "const nyCreatedAt = pm.environment.get(`tz_${nyKey}_created_at`);",
              "const madridCreatedAt = pm.environment.get(`tz_${madridKey}_created_at`);",
              "const nyHour = parseInt(pm.environment.get(`tz_${nyKey}_hour`) || \"0\");",
              "const madridHour = parseInt(pm.environment.get(`tz_${madridKey}_hour`) || \"0\");",
              "",
              "// 11. Perform comparison when we have both timezones",
              "if (nyCreatedAt && madridCreatedAt) {",
              "    console.log(\"\\nðŸ” TIMEZONE COMPARISON ANALYSIS:\");",
              "    console.log(`New York (${nyTZ}):    ${nyCreatedAt}`);",
              "    console.log(`Madrid (${madridTZ}):   ${madridCreatedAt}`);",
              "    ",
              "    const nyDateInfo = parseDateTime(nyCreatedAt);",
              "    const madridDateInfo = parseDateTime(madridCreatedAt);",
              "    ",
              "    // Calculate hour difference",
              "    const hourDifference = madridHour - nyHour;",
              "    ",
              "    // Adjust for day boundary (if Madrid is next day)",
              "    let adjustedHourDiff = hourDifference;",
              "    if (hourDifference < 0) {",
              "        adjustedHourDiff = 24 + hourDifference; // Madrid is next day",
              "    }",
              "    ",
              "    console.log(`\\nâ° HOUR DIFFERENCES:`);",
              "    console.log(`   Raw hour diff: ${hourDifference} hours`);",
              "    console.log(`   Adjusted diff: ${adjustedHourDiff} hours`);",
              "    ",
              "    // 12. Validate based on season",
              "    const nyMonth = parseInt(pm.environment.get(`tz_${nyKey}_month`) || currentMonth.toString());",
              "    const isNYDST = isSummerTime(nyMonth, nyDateInfo.day);",
              "    ",
              "    console.log(`\\nðŸŒ¤ SEASONAL ANALYSIS:`);",
              "    console.log(`   NY month: ${nyMonth} (${isNYDST ? 'Daylight Time' : 'Standard Time'})`);",
              "    console.log(`   Madrid month: ${currentMonth} (${isCurrentlyDST ? 'Summer Time' : 'Standard Time'})`);",
              "    ",
              "    // Expected differences based on season",
              "    const expectedDiffWinter = 6; // EST (UTC-5) vs CET (UTC+1)",
              "    const expectedDiffSummer = 6; // EDT (UTC-4) vs CEST (UTC+2) - STILL 6 HOURS!",
              "    ",
              "    // Madrid is always 6 hours ahead of New York",
              "    const expectedDifference = 6;",
              "    ",
              "    console.log(`\\nâœ… EXPECTED: Madrid should be ${expectedDifference} hours ahead of New York`);",
              "    console.log(`   (Always 6 hours regardless of DST)`);",
              "    ",
              "    // 13. Perform tests",
              "    pm.test(\"Madrid time is ahead of New York time\", function () {",
              "        const madridTimestamp = madridDateInfo.timestamp;",
              "        const nyTimestamp = nyDateInfo.timestamp;",
              "        pm.expect(madridTimestamp).to.be.greaterThan(nyTimestamp);",
              "        console.log(`   âœ“ Madrid timestamp > NY timestamp`);",
              "    });",
              "    ",
              "    pm.test(`Time difference is approximately ${expectedDifference} hours`, function () {",
              "        // Calculate exact difference in hours",
              "        const exactDiffHours = (madridDateInfo.timestamp - nyDateInfo.timestamp) / (1000 * 60 * 60);",
              "        console.log(`   Exact difference: ${exactDiffHours.toFixed(2)} hours`);",
              "        ",
              "        // Allow Â±0.5 hours for rounding/formatting",
              "        pm.expect(exactDiffHours).to.be.closeTo(expectedDifference, 0.5);",
              "        console.log(`   âœ“ Within expected range (${expectedDifference} Â± 0.5 hours)`);",
              "    });",
              "    ",
              "    pm.test(\"Hour values show correct relationship\", function () {",
              "        // When comparing hours directly (0-23 scale)",
              "        let expectedMadridHour = (nyHour + expectedDifference) % 24;",
              "        ",
              "        // Account for possible day difference",
              "        if (expectedMadridHour < 0) expectedMadridHour += 24;",
              "        ",
              "        console.log(`   NY hour: ${nyHour}:00`);",
              "        console.log(`   Expected Madrid hour: ${expectedMadridHour}:00`);",
              "        console.log(`   Actual Madrid hour: ${madridHour}:00`);",
              "        ",
              "        // Allow Â±1 hour for DST boundary cases",
              "        const hourDiff = Math.abs(madridHour - expectedMadridHour);",
              "        pm.expect(hourDiff).to.be.lessThan(2);",
              "    });",
              "    ",
              "    // 14. Day boundary check",
              "    const nyDay = nyDateInfo.day;",
              "    const madridDay = madridDateInfo.day;",
              "    const dayDiff = madridDay - nyDay;",
              "    ",
              "    console.log(`\\nðŸ“… DAY COMPARISON:`);",
              "    console.log(`   NY day: ${nyDay}`);",
              "    console.log(`   Madrid day: ${madridDay}`);",
              "    console.log(`   Day difference: ${dayDiff}`);",
              "    ",
              "    // Day difference should be 0 (same day) or 1 (Madrid is next day)",
              "    pm.test(\"Day difference is logical\", function () {",
              "        pm.expect(dayDiff).to.be.oneOf([0, 1]);",
              "        console.log(`   âœ“ Day difference is ${dayDiff} (logical)`);",
              "    });",
              "    ",
              "    // 15. Special case: When NY is late and Madrid is early next day",
              "    if (dayDiff === 1) {",
              "        console.log(`\\nðŸŒ™ SPECIAL CASE: Madrid is on next calendar day`);",
              "        console.log(`   This happens when NY time is 19:00-23:59`);",
              "        console.log(`   and Madrid time is 01:00-05:59 (next day)`);",
              "        ",
              "        pm.test(\"When days differ, hour relationship still holds\", function () {",
              "            // If Madrid is next day, its hour should be small (0-5)",
              "            // and NY hour should be large (19-23)",
              "            const isLateNY = nyHour >= 19 && nyHour <= 23;",
              "            const isEarlyMadrid = madridHour >= 0 && madridHour <= 5;",
              "            ",
              "            pm.expect(isLateNY && isEarlyMadrid).to.be.true;",
              "            console.log(`   âœ“ NY is late (${nyHour}:00), Madrid is early (${madridHour}:00)`);",
              "        });",
              "    }",
              "    ",
              "} else if (currentTimeZone === nyTZ) {",
              "    console.log(\"\\nðŸ’¡ NEXT STEP: Run this test again with:\");",
              "    console.log(`   Time-Zone: ${madridTZ}`);",
              "    console.log(`   Same endpoint: GET /api/nodes/1/`);",
              "    console.log(`\\nðŸ“‹ The test will then compare the 6-hour difference`);",
              "} else if (currentTimeZone === madridTZ) {",
              "    console.log(\"\\nðŸ’¡ NEED NY DATA: First run with:\");",
              "    console.log(`   Time-Zone: ${nyTZ}`);",
              "    console.log(`   Same endpoint: GET /api/nodes/1/`);",
              "}",
              "",
              "// 16. Clear old data if we're starting fresh",
              "if (!pm.environment.get(\"test_start_timestamp\")) {",
              "    pm.environment.set(\"test_start_timestamp\", Date.now().toString());",
              "    // Clear any old timezone data",
              "    pm.environment.unset(`tz_${nyKey}_created_at`);",
              "    pm.environment.unset(`tz_${madridKey}_created_at`);",
              "    console.log(\"\\nðŸ§¹ Starting fresh timezone comparison test\");",
              "}",
              "",
              "// 17. Performance check",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    console.log(`\\nâ± Response time: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 18. Final summary",
              "console.log(`\\nâœ… TEST SUMMARY FOR NODE 1:`);",
              "console.log(`   Timezone tested: ${currentTimeZone}`);",
              "console.log(`   Node 1 created_at: ${responseData.created_at}`);",
              "console.log(`   Status: ${pm.response.code}`);",
              "",
              "if (nyCreatedAt && madridCreatedAt) {",
              "    console.log(`\\nðŸŽ¯ COMPARISON RESULT:`);",
              "    console.log(`   Madrid is ~6 hours ahead of New York`);",
              "    console.log(`   âœ“ Timezone conversion working correctly`);",
              "} else {",
              "    console.log(`\\nðŸ”§ INSTRUCTIONS:`);",
              "    console.log(`   Run this test twice:`);",
              "    console.log(`   1. With Time-Zone: ${nyTZ}`);",
              "    console.log(`   2. With Time-Zone: ${madridTZ}`);",
              "    console.log(`   Both requests to: GET /api/nodes/1/`);",
              "}"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [
          {
            "key": "Time-Zone",
            "value": "America/New_York",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{LOCAL}}/nodes/1/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "1",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Eu_Madrid_Time",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Time Zone Difference for Node 1 (NY vs Madrid)",
              "// Endpoint: GET /api/nodes/1/",
              "// Tests: Time-Zone: Europe/Madrid vs Time-Zone: America/New_York",
              "// ============================================",
              "",
              "console.log(\"=== Test: Time Zone Difference for Node 1 ===\");",
              "",
              "// 1. Get current timezone being tested",
              "const currentTimeZone = pm.request.headers.get(\"Time-Zone\");",
              "pm.test(\"Time-Zone header is set\", function () {",
              "    pm.expect(currentTimeZone).to.exist;",
              "    pm.expect(currentTimeZone.trim().length).to.be.greaterThan(0);",
              "    console.log(`âœ“ Testing with Time-Zone: ${currentTimeZone}`);",
              "});",
              "",
              "// 2. Verify we're testing node 1",
              "const url = pm.request.url.toString();",
              "pm.test(\"Testing specific node 1\", function () {",
              "    pm.expect(url).to.include(\"/api/nodes/1/\");",
              "    console.log(`âœ“ Testing Node ID: 1`);",
              "});",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Verify we got node 1",
              "pm.test(\"Response is for node 1\", function () {",
              "    pm.expect(responseData.id).to.equal(1);",
              "    console.log(`âœ“ Got Node 1: \"${responseData.content}\"`);",
              "});",
              "",
              "// 6. Verify date format",
              "pm.test(\"created_at has correct format\", function () {",
              "    const datePattern = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "    pm.expect(responseData.created_at).to.match(datePattern);",
              "    console.log(`âœ“ created_at: ${responseData.created_at}`);",
              "});",
              "",
              "// 7. Parse the date for analysis",
              "const parseDateTime = (dateStr) => {",
              "    const [datePart, timePart] = dateStr.split(' ');",
              "    const [year, month, day] = datePart.split('-').map(Number);",
              "    const [hour, minute, second] = timePart.split(':').map(Number);",
              "    return {",
              "        year, month, day, hour, minute, second,",
              "        jsDate: new Date(year, month - 1, day, hour, minute, second),",
              "        timestamp: new Date(year, month - 1, day, hour, minute, second).getTime()",
              "    };",
              "};",
              "",
              "const currentDateInfo = parseDateTime(responseData.created_at);",
              "console.log(`\\nðŸ“… Current date analysis (${currentTimeZone}):`);",
              "console.log(`   Date: ${currentDateInfo.year}-${currentDateInfo.month}-${currentDateInfo.day}`);",
              "console.log(`   Time: ${currentDateInfo.hour}:${currentDateInfo.minute}:${currentDateInfo.second}`);",
              "",
              "// 8. Determine if we're in daylight saving time period",
              "const isSummerTime = (month, day) => {",
              "    // European Summer Time (Madrid): Last Sunday March to last Sunday October",
              "    // US Daylight Time (New York): Second Sunday March to first Sunday November",
              "    ",
              "    // Simple month-based approximation for test purposes",
              "    // March (3) to October (10) for Northern Hemisphere summer",
              "    return month >= 3 && month <= 10;",
              "};",
              "",
              "const currentMonth = currentDateInfo.month;",
              "const isCurrentlyDST = isSummerTime(currentMonth, currentDateInfo.day);",
              "console.log(`   Month: ${currentMonth} (${isCurrentlyDST ? 'Summer/DST season' : 'Winter/Standard season'})`);",
              "",
              "// 9. Save data based on timezone",
              "const tzKey = currentTimeZone.replace(/[\\/]/g, '_');",
              "pm.environment.set(`tz_${tzKey}_created_at`, responseData.created_at);",
              "pm.environment.set(`tz_${tzKey}_hour`, currentDateInfo.hour.toString());",
              "pm.environment.set(`tz_${tzKey}_timestamp`, currentDateInfo.timestamp.toString());",
              "pm.environment.set(`tz_${tzKey}_month`, currentMonth.toString());",
              "",
              "// 10. CRITICAL: Compare with other timezone if available",
              "const nyTZ = \"America/New_York\";",
              "const madridTZ = \"Europe/Madrid\";",
              "",
              "const nyKey = nyTZ.replace(/[\\/]/g, '_');",
              "const madridKey = madridTZ.replace(/[\\/]/g, '_');",
              "",
              "const nyCreatedAt = pm.environment.get(`tz_${nyKey}_created_at`);",
              "const madridCreatedAt = pm.environment.get(`tz_${madridKey}_created_at`);",
              "const nyHour = parseInt(pm.environment.get(`tz_${nyKey}_hour`) || \"0\");",
              "const madridHour = parseInt(pm.environment.get(`tz_${madridKey}_hour`) || \"0\");",
              "",
              "// 11. Perform comparison when we have both timezones",
              "if (nyCreatedAt && madridCreatedAt) {",
              "    console.log(\"\\nðŸ” TIMEZONE COMPARISON ANALYSIS:\");",
              "    console.log(`New York (${nyTZ}):    ${nyCreatedAt}`);",
              "    console.log(`Madrid (${madridTZ}):   ${madridCreatedAt}`);",
              "    ",
              "    const nyDateInfo = parseDateTime(nyCreatedAt);",
              "    const madridDateInfo = parseDateTime(madridCreatedAt);",
              "    ",
              "    // Calculate hour difference",
              "    const hourDifference = madridHour - nyHour;",
              "    ",
              "    // Adjust for day boundary (if Madrid is next day)",
              "    let adjustedHourDiff = hourDifference;",
              "    if (hourDifference < 0) {",
              "        adjustedHourDiff = 24 + hourDifference; // Madrid is next day",
              "    }",
              "    ",
              "    console.log(`\\nâ° HOUR DIFFERENCES:`);",
              "    console.log(`   Raw hour diff: ${hourDifference} hours`);",
              "    console.log(`   Adjusted diff: ${adjustedHourDiff} hours`);",
              "    ",
              "    // 12. Validate based on season",
              "    const nyMonth = parseInt(pm.environment.get(`tz_${nyKey}_month`) || currentMonth.toString());",
              "    const isNYDST = isSummerTime(nyMonth, nyDateInfo.day);",
              "    ",
              "    console.log(`\\nðŸŒ¤ SEASONAL ANALYSIS:`);",
              "    console.log(`   NY month: ${nyMonth} (${isNYDST ? 'Daylight Time' : 'Standard Time'})`);",
              "    console.log(`   Madrid month: ${currentMonth} (${isCurrentlyDST ? 'Summer Time' : 'Standard Time'})`);",
              "    ",
              "    // Expected differences based on season",
              "    const expectedDiffWinter = 6; // EST (UTC-5) vs CET (UTC+1)",
              "    const expectedDiffSummer = 6; // EDT (UTC-4) vs CEST (UTC+2) - STILL 6 HOURS!",
              "    ",
              "    // Madrid is always 6 hours ahead of New York",
              "    const expectedDifference = 6;",
              "    ",
              "    console.log(`\\nâœ… EXPECTED: Madrid should be ${expectedDifference} hours ahead of New York`);",
              "    console.log(`   (Always 6 hours regardless of DST)`);",
              "    ",
              "    // 13. Perform tests",
              "    pm.test(\"Madrid time is ahead of New York time\", function () {",
              "        const madridTimestamp = madridDateInfo.timestamp;",
              "        const nyTimestamp = nyDateInfo.timestamp;",
              "        pm.expect(madridTimestamp).to.be.greaterThan(nyTimestamp);",
              "        console.log(`   âœ“ Madrid timestamp > NY timestamp`);",
              "    });",
              "    ",
              "    pm.test(`Time difference is approximately ${expectedDifference} hours`, function () {",
              "        // Calculate exact difference in hours",
              "        const exactDiffHours = (madridDateInfo.timestamp - nyDateInfo.timestamp) / (1000 * 60 * 60);",
              "        console.log(`   Exact difference: ${exactDiffHours.toFixed(2)} hours`);",
              "        ",
              "        // Allow Â±0.5 hours for rounding/formatting",
              "        pm.expect(exactDiffHours).to.be.closeTo(expectedDifference, 0.5);",
              "        console.log(`   âœ“ Within expected range (${expectedDifference} Â± 0.5 hours)`);",
              "    });",
              "    ",
              "    pm.test(\"Hour values show correct relationship\", function () {",
              "        // When comparing hours directly (0-23 scale)",
              "        let expectedMadridHour = (nyHour + expectedDifference) % 24;",
              "        ",
              "        // Account for possible day difference",
              "        if (expectedMadridHour < 0) expectedMadridHour += 24;",
              "        ",
              "        console.log(`   NY hour: ${nyHour}:00`);",
              "        console.log(`   Expected Madrid hour: ${expectedMadridHour}:00`);",
              "        console.log(`   Actual Madrid hour: ${madridHour}:00`);",
              "        ",
              "        // Allow Â±1 hour for DST boundary cases",
              "        const hourDiff = Math.abs(madridHour - expectedMadridHour);",
              "        pm.expect(hourDiff).to.be.lessThan(2);",
              "    });",
              "    ",
              "    // 14. Day boundary check",
              "    const nyDay = nyDateInfo.day;",
              "    const madridDay = madridDateInfo.day;",
              "    const dayDiff = madridDay - nyDay;",
              "    ",
              "    console.log(`\\nðŸ“… DAY COMPARISON:`);",
              "    console.log(`   NY day: ${nyDay}`);",
              "    console.log(`   Madrid day: ${madridDay}`);",
              "    console.log(`   Day difference: ${dayDiff}`);",
              "    ",
              "    // Day difference should be 0 (same day) or 1 (Madrid is next day)",
              "    pm.test(\"Day difference is logical\", function () {",
              "        pm.expect(dayDiff).to.be.oneOf([0, 1]);",
              "        console.log(`   âœ“ Day difference is ${dayDiff} (logical)`);",
              "    });",
              "    ",
              "    // 15. Special case: When NY is late and Madrid is early next day",
              "    if (dayDiff === 1) {",
              "        console.log(`\\nðŸŒ™ SPECIAL CASE: Madrid is on next calendar day`);",
              "        console.log(`   This happens when NY time is 19:00-23:59`);",
              "        console.log(`   and Madrid time is 01:00-05:59 (next day)`);",
              "        ",
              "        pm.test(\"When days differ, hour relationship still holds\", function () {",
              "            // If Madrid is next day, its hour should be small (0-5)",
              "            // and NY hour should be large (19-23)",
              "            const isLateNY = nyHour >= 19 && nyHour <= 23;",
              "            const isEarlyMadrid = madridHour >= 0 && madridHour <= 5;",
              "            ",
              "            pm.expect(isLateNY && isEarlyMadrid).to.be.true;",
              "            console.log(`   âœ“ NY is late (${nyHour}:00), Madrid is early (${madridHour}:00)`);",
              "        });",
              "    }",
              "    ",
              "} else if (currentTimeZone === nyTZ) {",
              "    console.log(\"\\nðŸ’¡ NEXT STEP: Run this test again with:\");",
              "    console.log(`   Time-Zone: ${madridTZ}`);",
              "    console.log(`   Same endpoint: GET /api/nodes/1/`);",
              "    console.log(`\\nðŸ“‹ The test will then compare the 6-hour difference`);",
              "} else if (currentTimeZone === madridTZ) {",
              "    console.log(\"\\nðŸ’¡ NEED NY DATA: First run with:\");",
              "    console.log(`   Time-Zone: ${nyTZ}`);",
              "    console.log(`   Same endpoint: GET /api/nodes/1/`);",
              "}",
              "",
              "// 16. Clear old data if we're starting fresh",
              "if (!pm.environment.get(\"test_start_timestamp\")) {",
              "    pm.environment.set(\"test_start_timestamp\", Date.now().toString());",
              "    // Clear any old timezone data",
              "    pm.environment.unset(`tz_${nyKey}_created_at`);",
              "    pm.environment.unset(`tz_${madridKey}_created_at`);",
              "    console.log(\"\\nðŸ§¹ Starting fresh timezone comparison test\");",
              "}",
              "",
              "// 17. Performance check",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    console.log(`\\nâ± Response time: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 18. Final summary",
              "console.log(`\\nâœ… TEST SUMMARY FOR NODE 1:`);",
              "console.log(`   Timezone tested: ${currentTimeZone}`);",
              "console.log(`   Node 1 created_at: ${responseData.created_at}`);",
              "console.log(`   Status: ${pm.response.code}`);",
              "",
              "if (nyCreatedAt && madridCreatedAt) {",
              "    console.log(`\\nðŸŽ¯ COMPARISON RESULT:`);",
              "    console.log(`   Madrid is ~6 hours ahead of New York`);",
              "    console.log(`   âœ“ Timezone conversion working correctly`);",
              "} else {",
              "    console.log(`\\nðŸ”§ INSTRUCTIONS:`);",
              "    console.log(`   Run this test twice:`);",
              "    console.log(`   1. With Time-Zone: ${nyTZ}`);",
              "    console.log(`   2. With Time-Zone: ${madridTZ}`);",
              "    console.log(`   Both requests to: GET /api/nodes/1/`);",
              "}"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [
          {
            "key": "Time-Zone",
            "value": "Europe/Madrid",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{LOCAL}}/nodes/1/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "1",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Nodes_Tokio_Time",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Time Zone Difference for Node 1 (NY vs Tokyo)",
              "// Endpoint: GET /api/nodes/1/",
              "// Tests: Time-Zone: Asia/Tokyo vs Time-Zone: America/New_York",
              "// ============================================",
              "",
              "console.log(\"=== Test: Time Zone Difference NY vs Tokyo for Node 1 ===\");",
              "",
              "// 1. Get current timezone being tested",
              "const currentTimeZone = pm.request.headers.get(\"Time-Zone\");",
              "pm.test(\"Time-Zone header is set\", function () {",
              "    pm.expect(currentTimeZone).to.exist;",
              "    pm.expect(currentTimeZone.trim().length).to.be.greaterThan(0);",
              "    console.log(`âœ“ Testing with Time-Zone: ${currentTimeZone}`);",
              "});",
              "",
              "// 2. Verify we're testing node 1",
              "const url = pm.request.url.toString();",
              "pm.test(\"Testing specific node 1\", function () {",
              "    pm.expect(url).to.include(\"/api/nodes/1/\");",
              "    console.log(`âœ“ Testing Node ID: 1`);",
              "});",
              "",
              "// 3. Verify status code",
              "pm.test(\"Status code is 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 4. Parse response",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Response is valid JSON\", function () {",
              "        pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
              "    });",
              "    return;",
              "}",
              "",
              "// 5. Verify we got node 1",
              "pm.test(\"Response is for node 1\", function () {",
              "    pm.expect(responseData.id).to.equal(1);",
              "    console.log(`âœ“ Got Node 1: \"${responseData.content}\"`);",
              "});",
              "",
              "// 6. Verify date format",
              "pm.test(\"created_at has correct format\", function () {",
              "    const datePattern = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "    pm.expect(responseData.created_at).to.match(datePattern);",
              "    console.log(`âœ“ created_at: ${responseData.created_at}`);",
              "});",
              "",
              "// 7. Parse the date for analysis",
              "const parseDateTime = (dateStr) => {",
              "    const [datePart, timePart] = dateStr.split(' ');",
              "    const [year, month, day] = datePart.split('-').map(Number);",
              "    const [hour, minute, second] = timePart.split(':').map(Number);",
              "    return {",
              "        year, month, day, hour, minute, second,",
              "        jsDate: new Date(year, month - 1, day, hour, minute, second),",
              "        timestamp: new Date(year, month - 1, day, hour, minute, second).getTime()",
              "    };",
              "};",
              "",
              "const currentDateInfo = parseDateTime(responseData.created_at);",
              "console.log(`\\nðŸ“… Current date analysis (${currentTimeZone}):`);",
              "console.log(`   Date: ${currentDateInfo.year}-${currentDateInfo.month}-${currentDateInfo.day}`);",
              "console.log(`   Time: ${currentDateInfo.hour}:${String(currentDateInfo.minute).padStart(2, '0')}:${String(currentDateInfo.second).padStart(2, '0')}`);",
              "",
              "// 8. Determine current season for DST analysis",
              "const isSummerTimeUS = (month, day) => {",
              "    // US Daylight Time: Second Sunday March (approx. March 8-14) to first Sunday November (approx. Nov 1-7)",
              "    // Simplified: March to October",
              "    return month >= 3 && month <= 10;",
              "};",
              "",
              "const currentMonth = currentDateInfo.month;",
              "const isCurrentlyDSTinUS = isSummerTimeUS(currentMonth, currentDateInfo.day);",
              "console.log(`   Month: ${currentMonth} (${isCurrentlyDSTinUS ? 'US DST period' : 'US Standard Time'})`);",
              "",
              "// 9. Save data based on timezone",
              "const tzKey = currentTimeZone.replace(/[\\/]/g, '_');",
              "pm.environment.set(`tz_tokyo_${tzKey}_created_at`, responseData.created_at);",
              "pm.environment.set(`tz_tokyo_${tzKey}_hour`, currentDateInfo.hour.toString());",
              "pm.environment.set(`tz_tokyo_${tzKey}_minute`, currentDateInfo.minute.toString());",
              "pm.environment.set(`tz_tokyo_${tzKey}_timestamp`, currentDateInfo.timestamp.toString());",
              "pm.environment.set(`tz_tokyo_${tzKey}_month`, currentMonth.toString());",
              "",
              "// 10. CRITICAL: Compare with other timezone if available",
              "const nyTZ = \"America/New_York\";",
              "const tokyoTZ = \"Asia/Tokyo\";",
              "",
              "const nyKey = nyTZ.replace(/[\\/]/g, '_');",
              "const tokyoKey = tokyoTZ.replace(/[\\/]/g, '_');",
              "",
              "const nyCreatedAt = pm.environment.get(`tz_tokyo_${nyKey}_created_at`);",
              "const tokyoCreatedAt = pm.environment.get(`tz_tokyo_${tokyoKey}_created_at`);",
              "const nyHour = parseInt(pm.environment.get(`tz_tokyo_${nyKey}_hour`) || \"0\");",
              "const tokyoHour = parseInt(pm.environment.get(`tz_tokyo_${tokyoKey}_hour`) || \"0\");",
              "",
              "// 11. Calculate expected time difference",
              "let expectedDifference;",
              "if (isCurrentlyDSTinUS) {",
              "    // US Daylight Time (EDT): UTC-4",
              "    // Tokyo (JST): UTC+9 (NO DST in Japan)",
              "    expectedDifference = 13; // 9 - (-4) = 13 hours",
              "    console.log(`\\nðŸŒ¤ SEASON: US Daylight Time (EDT = UTC-4)`);",
              "    console.log(`   Tokyo Standard Time (JST = UTC+9)`);",
              "    console.log(`   Expected difference: ${expectedDifference} hours (Tokyo ahead)`);",
              "} else {",
              "    // US Standard Time (EST): UTC-5  ",
              "    // Tokyo (JST): UTC+9 (NO DST in Japan)",
              "    expectedDifference = 14; // 9 - (-5) = 14 hours",
              "    console.log(`\\nðŸŒ¤ SEASON: US Standard Time (EST = UTC-5)`);",
              "    console.log(`   Tokyo Standard Time (JST = UTC+9)`);",
              "    console.log(`   Expected difference: ${expectedDifference} hours (Tokyo ahead)`);",
              "}",
              "",
              "// 12. Perform comparison when we have both timezones",
              "if (nyCreatedAt && tokyoCreatedAt) {",
              "    console.log(\"\\nðŸ” TIMEZONE COMPARISON ANALYSIS:\");",
              "    console.log(`New York (${nyTZ}):    ${nyCreatedAt}`);",
              "    console.log(`Tokyo (${tokyoTZ}):     ${tokyoCreatedAt}`);",
              "    ",
              "    const nyDateInfo = parseDateTime(nyCreatedAt);",
              "    const tokyoDateInfo = parseDateTime(tokyoCreatedAt);",
              "    ",
              "    // Calculate exact difference in hours",
              "    const exactDiffMs = tokyoDateInfo.timestamp - nyDateInfo.timestamp;",
              "    const exactDiffHours = exactDiffMs / (1000 * 60 * 60);",
              "    ",
              "    console.log(`\\nâ° EXACT DIFFERENCE:`);",
              "    console.log(`   ${exactDiffHours.toFixed(2)} hours`);",
              "    console.log(`   Expected: ${expectedDifference} hours`);",
              "    ",
              "    // 13. Validate time difference",
              "    pm.test(`Tokyo is approximately ${expectedDifference} hours ahead of New York`, function () {",
              "        // Allow Â±0.5 hours for rounding/formatting",
              "        pm.expect(exactDiffHours).to.be.closeTo(expectedDifference, 0.5);",
              "        console.log(`   âœ“ Within expected range (${expectedDifference} Â± 0.5 hours)`);",
              "    });",
              "    ",
              "    pm.test(\"Tokyo time is ahead of New York time\", function () {",
              "        pm.expect(tokyoDateInfo.timestamp).to.be.greaterThan(nyDateInfo.timestamp);",
              "        console.log(`   âœ“ Tokyo timestamp > NY timestamp`);",
              "    });",
              "    ",
              "    // 14. Calculate day difference",
              "    const nyDay = nyDateInfo.day;",
              "    const tokyoDay = tokyoDateInfo.day;",
              "    const dayDiff = tokyoDay - nyDay;",
              "    ",
              "    console.log(`\\nðŸ“… DAY ANALYSIS:`);",
              "    console.log(`   NY day: ${nyDay}`);",
              "    console.log(`   Tokyo day: ${tokyoDay}`);",
              "    console.log(`   Day difference: ${dayDiff}`);",
              "    ",
              "    // For 13-14 hour difference, Tokyo could be 0 or 1 day ahead",
              "    pm.test(\"Day difference is logical (0 or 1)\", function () {",
              "        pm.expect(dayDiff).to.be.oneOf([0, 1]);",
              "        console.log(`   âœ“ Day difference is ${dayDiff} (logical)`);",
              "    });",
              "    ",
              "    // 15. Analyze time relationship",
              "    console.log(`\\nðŸ• TIME RELATIONSHIP:`);",
              "    console.log(`   NY time: ${nyHour}:00`);",
              "    console.log(`   Tokyo time: ${tokyoHour}:00`);",
              "    ",
              "    // Calculate expected Tokyo hour based on NY hour",
              "    let expectedTokyoHour = (nyHour + expectedDifference) % 24;",
              "    if (expectedTokyoHour < 0) expectedTokyoHour += 24;",
              "    ",
              "    console.log(`   Expected Tokyo hour: ${expectedTokyoHour}:00`);",
              "    console.log(`   Actual Tokyo hour: ${tokyoHour}:00`);",
              "    ",
              "    pm.test(\"Tokyo hour matches expected relationship\", function () {",
              "        const hourDiff = Math.abs(tokyoHour - expectedTokyoHour);",
              "        // Allow Â±2 hours for day boundary and DST transitions",
              "        pm.expect(hourDiff).to.be.lessThan(3);",
              "        console.log(`   âœ“ Hour difference: ${hourDiff} (acceptable)`);",
              "    });",
              "    ",
              "    // 16. Special scenarios based on day difference",
              "    if (dayDiff === 1) {",
              "        console.log(`\\nðŸŒ™ SPECIAL SCENARIO: Tokyo is on next day`);",
              "        console.log(`   This happens when NY time makes Tokyo cross midnight`);",
              "        ",
              "        // When Tokyo is next day, verify NY is late evening",
              "        const isLateNY = nyHour >= (24 - expectedDifference);",
              "        pm.test(\"When Tokyo is next day, NY is late evening\", function () {",
              "            pm.expect(isLateNY).to.be.true;",
              "            console.log(`   âœ“ NY is late evening (${nyHour}:00)`);",
              "        });",
              "        ",
              "        // Tokyo should be early morning",
              "        const isEarlyTokyo = tokyoHour < expectedDifference;",
              "        pm.test(\"When Tokyo is next day, it's early morning\", function () {",
              "            pm.expect(isEarlyTokyo).to.be.true;",
              "            console.log(`   âœ“ Tokyo is early morning (${tokyoHour}:00)`);",
              "        });",
              "    } else {",
              "        console.log(`\\nðŸŒž NORMAL SCENARIO: Same calendar day`);",
              "        console.log(`   Tokyo is ${expectedDifference} hours ahead but same day`);",
              "    }",
              "    ",
              "    // 17. Validate DST logic",
              "    const nyMonth = parseInt(pm.environment.get(`tz_tokyo_${nyKey}_month`) || currentMonth.toString());",
              "    const isNYDST = isSummerTimeUS(nyMonth, nyDateInfo.day);",
              "    ",
              "    console.log(`\\nðŸ”¬ DST VALIDATION:`);",
              "    console.log(`   NY month: ${nyMonth} (${isNYDST ? 'Daylight Time' : 'Standard Time'})`);",
              "    console.log(`   Current expected diff: ${expectedDifference} hours`);",
              "    ",
              "    // Verify expected difference matches season",
              "    const calculatedDiff = isNYDST ? 13 : 14;",
              "    pm.test(\"Time difference matches DST season\", function () {",
              "        pm.expect(expectedDifference).to.equal(calculatedDiff);",
              "        console.log(`   âœ“ Difference (${expectedDifference}h) matches DST season`);",
              "    });",
              "    ",
              "} else if (currentTimeZone === nyTZ) {",
              "    console.log(\"\\nðŸ’¡ NEXT STEP: Run this test again with:\");",
              "    console.log(`   Time-Zone: ${tokyoTZ}`);",
              "    console.log(`   Same endpoint: GET /api/nodes/1/`);",
              "    console.log(`\\nðŸ“‹ The test will then compare the time difference`);",
              "    console.log(`   Expected: Tokyo ${expectedDifference} hours ahead of NY`);",
              "} else if (currentTimeZone === tokyoTZ) {",
              "    console.log(\"\\nðŸ’¡ NEED NY DATA: First run with:\");",
              "    console.log(`   Time-Zone: ${nyTZ}`);",
              "    console.log(`   Same endpoint: GET /api/nodes/1/`);",
              "    console.log(`\\nðŸ“‹ Then this test will compare the time difference`);",
              "}",
              "",
              "// 18. Clear old data if we're starting fresh Tokyo test",
              "if (!pm.environment.get(\"tokyo_test_start_timestamp\")) {",
              "    pm.environment.set(\"tokyo_test_start_timestamp\", Date.now().toString());",
              "    // Clear any old Tokyo comparison data",
              "    pm.environment.unset(`tz_tokyo_${nyKey}_created_at`);",
              "    pm.environment.unset(`tz_tokyo_${tokyoKey}_created_at`);",
              "    console.log(\"\\nðŸ§¹ Starting fresh Tokyo timezone comparison\");",
              "}",
              "",
              "// 19. Performance check",
              "pm.test(\"Response time is acceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    console.log(`\\nâ± Response time: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 20. Final summary",
              "console.log(`\\nâœ… TOKYO TIMEZONE TEST SUMMARY:`);",
              "console.log(`   Timezone tested: ${currentTimeZone}`);",
              "console.log(`   Node 1 created_at: ${responseData.created_at}`);",
              "console.log(`   Status: ${pm.response.code}`);",
              "",
              "if (nyCreatedAt && tokyoCreatedAt) {",
              "    console.log(`\\nðŸŽ¯ COMPARISON RESULT:`);",
              "    console.log(`   Tokyo is ${expectedDifference} hours ahead of New York`);",
              "    console.log(`   âœ“ Timezone conversion working correctly`);",
              "    ",
              "    // Show interesting fact",
              "    if (expectedDifference === 13) {",
              "        console.log(`\\nðŸ’¡ INTERESTING FACT: When NY has DST, Tokyo is 13 hours ahead`);",
              "        console.log(`   (NY afternoon = Tokyo early morning NEXT DAY)`);",
              "    } else {",
              "        console.log(`\\nðŸ’¡ INTERESTING FACT: When NY has standard time, Tokyo is 14 hours ahead`);",
              "        console.log(`   (NY morning = Tokyo late evening SAME DAY)`);",
              "    }",
              "} else {",
              "    console.log(`\\nðŸ”§ INSTRUCTIONS:`);",
              "    console.log(`   Run this test twice:`);",
              "    console.log(`   1. With Time-Zone: ${nyTZ}`);",
              "    console.log(`   2. With Time-Zone: ${tokyoTZ}`);",
              "    console.log(`   Both requests to: GET /api/nodes/1/`);",
              "    console.log(`\\nâ° EXPECTED DIFFERENCE:`);",
              "    console.log(`   US DST period (Mar-Oct): Tokyo 13 hours ahead`);",
              "    console.log(`   US Standard time (Nov-Feb): Tokyo 14 hours ahead`);",
              "    console.log(`   (Japan does NOT observe Daylight Saving Time)`);",
              "}"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [
          {
            "key": "Time-Zone",
            "value": "Asia/Tokyo",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{LOCAL}}/nodes/1/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "1",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Create_Node_1",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Crear nodo hijo bajo nodo padre (ID=1)",
              "// Endpoint: POST /nodes/   ({{LOCAL}}/nodes/)",
              "// Guarda ID en variable GLOBAL: CAPTURE_NODE_ID_1",
              "// ============================================",
              "",
              "console.log(\"=== Test: Crear Nodo Hijo y Capturar ID (GLOBAL) ===\");",
              "",
              "// 1. Verificar status code 201 Created",
              "pm.test(\"Status code es 201 Created\", function () {",
              "    pm.response.to.have.status(201);",
              "});",
              "",
              "// 2. Parsear respuesta JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. CAPTURAR EL ID EN LA VARIABLE GLOBAL CAPTURE_NODE_ID_1",
              "if (responseData && responseData.id) {",
              "    const nodeId = responseData.id.toString();",
              "",
              "    // GUARDAR COMO VARIABLE GLOBAL",
              "    pm.globals.set(\"CAPTURE_NODE_ID_1\", nodeId);",
              "",
              "    // DEBUG: Verificar inmediatamente despuÃ©s de guardar",
              "    const immediateCheck = pm.globals.get(\"CAPTURE_NODE_ID_1\");",
              "    console.log(`DEBUG: ID recibido: ${responseData.id}`);",
              "    console.log(`DEBUG: Guardando en GLOBAL como string: \"${nodeId}\"`);",
              "    console.log(`DEBUG: VerificaciÃ³n inmediata GLOBAL: \"${immediateCheck}\"`);",
              "    console.log(`DEBUG: Son iguales? ${immediateCheck === nodeId}`);",
              "    console.log(`âœ… ID CAPTURADO EN GLOBAL: ${responseData.id} -> CAPTURE_NODE_ID_1`);",
              "",
              "    // 4. Tests para asegurar que se guardÃ³ bien en global",
              "    pm.test(\"ID capturado en variable GLOBAL CAPTURE_NODE_ID_1\", function () {",
              "        const capturedId = pm.globals.get(\"CAPTURE_NODE_ID_1\");",
              "        pm.expect(capturedId, \"La variable GLOBAL CAPTURE_NODE_ID_1 debe existir\").to.exist;",
              "        pm.expect(capturedId, \"La variable GLOBAL CAPTURE_NODE_ID_1 no debe estar vacÃ­a\").to.not.be.empty;",
              "        pm.expect(capturedId, \"La variable GLOBAL CAPTURE_NODE_ID_1 debe ser string\").to.be.a(\"string\");",
              "        pm.expect(capturedId, \"Valor guardado debe coincidir con el ID de respuesta\")",
              "            .to.equal(nodeId);",
              "    });",
              "",
              "    pm.test(\"Variable GLOBAL CAPTURE_NODE_ID_1 estÃ¡ disponible para uso futuro\", function () {",
              "        const capturedId = pm.globals.get(\"CAPTURE_NODE_ID_1\");",
              "        pm.expect(capturedId).to.equal(nodeId);",
              "    });",
              "",
              "} else {",
              "    console.log(\"âŒ La respuesta no contiene campo 'id'. Body:\", responseData);",
              "    pm.test(\"Respuesta contiene campo 'id'\", function () {",
              "        pm.expect.fail(\"La respuesta no tiene la propiedad 'id'.\");",
              "    });",
              "}"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"content\": \"Nodo para test 1\",\n    \"parent\": 1\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Create_Node_1_Again_Must_Fail",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Create_Node_1_Again_Must_Fail",
              "// Endpoint: POST /api/nodes/",
              "// Escenario: Intentar crear nodo con mismo tÃ­tulo en mismo nivel (parent=1)",
              "// Debe fallar con 400 Bad Request",
              "// ============================================",
              "",
              "console.log(\"=== Test: Crear nodo duplicado debe fallar (400) ===\");",
              "",
              "// 1. Verificar que falla con status 400 Bad Request",
              "pm.test(\"Status code es 400 Bad Request\", function () {",
              "    pm.response.to.have.status(400);",
              "});",
              "",
              "// 2. Parsear respuesta JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. Analizar estructura del error",
              "if (responseData) {",
              "    console.log(\"Estructura de error recibida:\", JSON.stringify(responseData, null, 2));",
              "    ",
              "    // CASO 1: Error de tÃ­tulo duplicado (como en tu ejemplo)",
              "    if (responseData.title && Array.isArray(responseData.title)) {",
              "        ",
              "        console.log(\"âœ“ Detectado: Error de tÃ­tulo duplicado\");",
              "        ",
              "        // 4. Verificar estructura especÃ­fica",
              "        pm.test(\"Error de tÃ­tulo duplicado tiene estructura correcta\", function () {",
              "            pm.expect(responseData).to.have.property(\"title\");",
              "            pm.expect(responseData.title).to.be.an(\"array\");",
              "            pm.expect(responseData.title.length).to.be.greaterThan(0);",
              "        });",
              "        ",
              "        // 5. Verificar mensaje especÃ­fico",
              "        const errorMessage = responseData.title[0];",
              "        pm.test(\"Mensaje de error es el esperado\", function () {",
              "            pm.expect(errorMessage).to.include(\"Ya existe un nodo activo con el tÃ­tulo\");",
              "            pm.expect(errorMessage).to.include(\"en este nivel\");",
              "            console.log(`âœ“ Mensaje de error: \"${errorMessage}\"`);",
              "        });",
              "        ",
              "        // 6. Verificar que NO tiene propiedades de Ã©xito",
              "        pm.test(\"No tiene propiedades de nodo creado\", function () {",
              "            pm.expect(responseData).to.not.have.property(\"id\");",
              "            pm.expect(responseData).to.not.have.property(\"parent\");",
              "            pm.expect(responseData).to.not.have.property(\"created_at\");",
              "        });",
              "        ",
              "    } ",
              "    // CASO 2: Otro tipo de error 400 (validaciÃ³n)",
              "    else if (responseData.detail || responseData.message) {",
              "        ",
              "        console.log(\"âœ“ Detectado: Otro tipo de error de validaciÃ³n\");",
              "        ",
              "        pm.test(\"Tiene mensaje de error\", function () {",
              "            const hasDetail = responseData.detail && typeof responseData.detail === \"string\";",
              "            const hasMessage = responseData.message && typeof responseData.message === \"string\";",
              "            pm.expect(hasDetail || hasMessage).to.be.true;",
              "        });",
              "        ",
              "        if (responseData.detail) {",
              "            console.log(`âœ“ Detail: ${responseData.detail}`);",
              "        }",
              "        if (responseData.message) {",
              "            console.log(`âœ“ Message: ${responseData.message}`);",
              "        }",
              "    }",
              "    // CASO 3: Error con estructura diferente",
              "    else {",
              "        console.log(\"âš  Estructura de error no reconocida, pero es objeto JSON\");",
              "        ",
              "        pm.test(\"Al menos tiene alguna propiedad\", function () {",
              "            const keys = Object.keys(responseData);",
              "            pm.expect(keys.length).to.be.greaterThan(0);",
              "            console.log(`Propiedades: ${keys.join(\", \")}`);",
              "        });",
              "    }",
              "}",
              "",
              "// 7. Verificar headers comunes",
              "pm.test(\"Headers de respuesta correctos\", function () {",
              "    // Content-Type debe ser JSON",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    ",
              "    // NO debe tener Location header (porque no se creÃ³)",
              "    const locationHeader = pm.response.headers.get(\"Location\");",
              "    pm.expect(locationHeader).to.not.exist;",
              "    ",
              "    // Headers de seguridad",
              "    const xContentTypeOptions = pm.response.headers.get(\"X-Content-Type-Options\");",
              "    if (xContentTypeOptions) {",
              "        pm.expect(xContentTypeOptions).to.equal(\"nosniff\");",
              "    }",
              "});",
              "",
              "// 8. Verificar tiempo de respuesta (debe ser rÃ¡pido para error)",
              "pm.test(\"Tiempo de respuesta rÃ¡pido\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(200);",
              "    console.log(`âœ“ Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 9. Verificar tamaÃ±o de respuesta (pequeÃ±o para error)",
              "pm.test(\"TamaÃ±o de respuesta adecuado\", function () {",
              "    pm.expect(pm.response.responseSize).to.be.below(500);",
              "    console.log(`âœ“ TamaÃ±o de respuesta: ${pm.response.responseSize} bytes`);",
              "});",
              "",
              "// 10. Test de integridad del error",
              "pm.test(\"Integridad del error 400\", function () {",
              "    const criticalChecks = [",
              "        { name: \"Status 400\", check: pm.response.code === 400 },",
              "        { name: \"Es JSON\", check: responseData !== null },",
              "        { name: \"Tiene mensaje\", check: responseData && (",
              "            (responseData.title && Array.isArray(responseData.title)) ||",
              "            responseData.detail ||",
              "            responseData.message ||",
              "            Object.keys(responseData).length > 0",
              "        )}",
              "    ];",
              "    ",
              "    let allPassed = true;",
              "    criticalChecks.forEach(check => {",
              "        console.log(`${check.name}: ${check.check ? 'âœ…' : 'âŒ'}`);",
              "        if (!check.check) allPassed = false;",
              "    });",
              "    ",
              "    pm.expect(allPassed, \"Fallo una verificaciÃ³n crÃ­tica del error 400\").to.be.true;",
              "    console.log(\"âœ… Todas las verificaciones crÃ­ticas pasaron\");",
              "});",
              "",
              "// 11. InformaciÃ³n para debugging",
              "console.log(\"\\n=== RESUMEN DEL ERROR 400 ===\");",
              "console.log(\"âœ… Comportamiento esperado: No se puede crear nodo con tÃ­tulo duplicado\");",
              "console.log(\"âœ… Parent ID usado: 1 (mismo nivel)\");",
              "console.log(\"âœ… TÃ­tulo duplicado: 'Nodo para test 1'\");",
              "console.log(\"âœ… La API correctamente rechaza la creaciÃ³n duplicada\");",
              "",
              "// 12. Limpiar variable temporal si existÃ­a (opcional)",
              "if (pm.environment.get(\"intento_fallido_nodo\")) {",
              "    pm.environment.unset(\"intento_fallido_nodo\");",
              "}",
              "",
              "console.log(\"=== Test de error por duplicado completado ===\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"title\": \"Nodo para test 1\",\n    \"parent\": 1\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Create_Node_2",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Create_Node_2 - Child of Node 1",
              "// Endpoint: POST {{LOCAL}}/nodes/",
              "// Captura ID en variable GLOBAL: CAPTURE_NODE_ID_2",
              "// ============================================",
              "",
              "console.log(\"=== Test: Create_Node_2 - Child of Node 1 (GLOBAL CAPTURE_NODE_ID_2) ===\");",
              "",
              "// 1. Verificar status code 201 Created",
              "pm.test(\"Status code es 201 Created\", function () {",
              "    pm.response.to.have.status(201);",
              "});",
              "",
              "// 2. Parsear respuesta JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. DEBUG: Mostrar quÃ© parent ID se usÃ³",
              "const requestBody = JSON.parse(pm.request.body.raw || \"{}\");",
              "console.log(\"DEBUG - Request body enviado:\");",
              "console.log(`  title: \"${requestBody.title}\"`);",
              "console.log(`  parent: ${requestBody.parent}`);",
              "console.log(`  parent variable CAPTURE_NODE_ID_1 (GLOBAL) = ${pm.globals.get(\"CAPTURE_NODE_ID_1\")}`);",
              "",
              "// 4. CAPTURAR EL ID DEL NUEVO NODO (Nodo 2) EN VARIABLE GLOBAL",
              "if (responseData && responseData.id) {",
              "    const nodeId = responseData.id.toString();",
              "",
              "    // Guardar como variable GLOBAL",
              "    pm.globals.set(\"CAPTURE_NODE_ID_2\", nodeId);",
              "",
              "    // DEBUG inmediato",
              "    const immediateCheck = pm.globals.get(\"CAPTURE_NODE_ID_2\");",
              "    console.log(`DEBUG: ID recibido: ${responseData.id}`);",
              "    console.log(`DEBUG: Guardando en GLOBAL CAPTURE_NODE_ID_2 como string: \"${nodeId}\"`);",
              "    console.log(`DEBUG: VerificaciÃ³n inmediata GLOBAL CAPTURE_NODE_ID_2: \"${immediateCheck}\"`);",
              "    console.log(`DEBUG: Son iguales? ${immediateCheck === nodeId}`);",
              "    console.log(`âœ… ID CAPTURADO EN GLOBAL: ${responseData.id} -> CAPTURE_NODE_ID_2`);",
              "",
              "    // 5. Verificar que la variable GLOBAL se guardÃ³ correctamente",
              "    pm.test(\"ID capturado en variable GLOBAL CAPTURE_NODE_ID_2\", function () {",
              "        const capturedId = pm.globals.get(\"CAPTURE_NODE_ID_2\");",
              "        pm.expect(capturedId, \"La variable GLOBAL CAPTURE_NODE_ID_2 debe existir\").to.exist;",
              "        pm.expect(capturedId, \"La variable GLOBAL CAPTURE_NODE_ID_2 no debe estar vacÃ­a\").to.not.be.empty;",
              "        pm.expect(capturedId, \"La variable GLOBAL CAPTURE_NODE_ID_2 debe ser string\").to.be.a(\"string\");",
              "        pm.expect(capturedId, \"Valor guardado debe coincidir con el ID de respuesta\")",
              "            .to.equal(nodeId);",
              "    });",
              "",
              "    // 6. (Opcional) Verificar relaciÃ³n padre-hijo con CAPTURE_NODE_ID_1",
              "    const parentNodeId = pm.globals.get(\"CAPTURE_NODE_ID_1\");",
              "    if (parentNodeId && parentNodeId !== \"0\") {",
              "        pm.test(\"Nodo 2 es hijo del Nodo 1 (CAPTURE_NODE_ID_1)\", function () {",
              "            pm.expect(responseData.parent, \"El parent del nodo 2 debe coincidir con CAPTURE_NODE_ID_1\")",
              "                .to.equal(parseInt(parentNodeId, 10));",
              "        });",
              "    } else {",
              "        console.log(\"âš  No se encontrÃ³ CAPTURE_NODE_ID_1 en globales para verificar relaciÃ³n padre-hijo.\");",
              "    }",
              "",
              "} else {",
              "    console.log(\"âŒ La respuesta no contiene campo 'id'. Body:\", responseData);",
              "    pm.test(\"Respuesta contiene campo 'id'\", function () {",
              "        pm.expect.fail(\"La respuesta no tiene la propiedad 'id'.\");",
              "    });",
              "}"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"content\": \"Nodo para test 2\",\n    \"parent\": {{CAPTURE_NODE_ID_1}}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ]
        },
        "description": "Chil of Node 1"
      },
      "response": []
    },
    {
      "name": "Create_Node_2_Again_Must_Fail Copy",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Create_Node_1_Again_Must_Fail",
              "// Endpoint: POST /api/nodes/",
              "// Escenario: Intentar crear nodo con mismo tÃ­tulo en mismo nivel (parent=1)",
              "// Debe fallar con 400 Bad Request",
              "// ============================================",
              "",
              "console.log(\"=== Test: Crear nodo duplicado debe fallar (400) ===\");",
              "",
              "// 1. Verificar que falla con status 400 Bad Request",
              "pm.test(\"Status code es 400 Bad Request\", function () {",
              "    pm.response.to.have.status(400);",
              "});",
              "",
              "// 2. Parsear respuesta JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. Analizar estructura del error",
              "if (responseData) {",
              "    console.log(\"Estructura de error recibida:\", JSON.stringify(responseData, null, 2));",
              "    ",
              "    // CASO 1: Error de tÃ­tulo duplicado (como en tu ejemplo)",
              "    if (responseData.title && Array.isArray(responseData.title)) {",
              "        ",
              "        console.log(\"âœ“ Detectado: Error de tÃ­tulo duplicado\");",
              "        ",
              "        // 4. Verificar estructura especÃ­fica",
              "        pm.test(\"Error de tÃ­tulo duplicado tiene estructura correcta\", function () {",
              "            pm.expect(responseData).to.have.property(\"title\");",
              "            pm.expect(responseData.title).to.be.an(\"array\");",
              "            pm.expect(responseData.title.length).to.be.greaterThan(0);",
              "        });",
              "        ",
              "        // 5. Verificar mensaje especÃ­fico",
              "        const errorMessage = responseData.title[0];",
              "        pm.test(\"Mensaje de error es el esperado\", function () {",
              "            pm.expect(errorMessage).to.include(\"Ya existe un nodo activo con el tÃ­tulo\");",
              "            pm.expect(errorMessage).to.include(\"en este nivel\");",
              "            console.log(`âœ“ Mensaje de error: \"${errorMessage}\"`);",
              "        });",
              "        ",
              "        // 6. Verificar que NO tiene propiedades de Ã©xito",
              "        pm.test(\"No tiene propiedades de nodo creado\", function () {",
              "            pm.expect(responseData).to.not.have.property(\"id\");",
              "            pm.expect(responseData).to.not.have.property(\"parent\");",
              "            pm.expect(responseData).to.not.have.property(\"created_at\");",
              "        });",
              "        ",
              "    } ",
              "    // CASO 2: Otro tipo de error 400 (validaciÃ³n)",
              "    else if (responseData.detail || responseData.message) {",
              "        ",
              "        console.log(\"âœ“ Detectado: Otro tipo de error de validaciÃ³n\");",
              "        ",
              "        pm.test(\"Tiene mensaje de error\", function () {",
              "            const hasDetail = responseData.detail && typeof responseData.detail === \"string\";",
              "            const hasMessage = responseData.message && typeof responseData.message === \"string\";",
              "            pm.expect(hasDetail || hasMessage).to.be.true;",
              "        });",
              "        ",
              "        if (responseData.detail) {",
              "            console.log(`âœ“ Detail: ${responseData.detail}`);",
              "        }",
              "        if (responseData.message) {",
              "            console.log(`âœ“ Message: ${responseData.message}`);",
              "        }",
              "    }",
              "    // CASO 3: Error con estructura diferente",
              "    else {",
              "        console.log(\"âš  Estructura de error no reconocida, pero es objeto JSON\");",
              "        ",
              "        pm.test(\"Al menos tiene alguna propiedad\", function () {",
              "            const keys = Object.keys(responseData);",
              "            pm.expect(keys.length).to.be.greaterThan(0);",
              "            console.log(`Propiedades: ${keys.join(\", \")}`);",
              "        });",
              "    }",
              "}",
              "",
              "// 7. Verificar headers comunes",
              "pm.test(\"Headers de respuesta correctos\", function () {",
              "    // Content-Type debe ser JSON",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    ",
              "    // NO debe tener Location header (porque no se creÃ³)",
              "    const locationHeader = pm.response.headers.get(\"Location\");",
              "    pm.expect(locationHeader).to.not.exist;",
              "    ",
              "    // Headers de seguridad",
              "    const xContentTypeOptions = pm.response.headers.get(\"X-Content-Type-Options\");",
              "    if (xContentTypeOptions) {",
              "        pm.expect(xContentTypeOptions).to.equal(\"nosniff\");",
              "    }",
              "});",
              "",
              "// 8. Verificar tiempo de respuesta (debe ser rÃ¡pido para error)",
              "pm.test(\"Tiempo de respuesta rÃ¡pido\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(200);",
              "    console.log(`âœ“ Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 9. Verificar tamaÃ±o de respuesta (pequeÃ±o para error)",
              "pm.test(\"TamaÃ±o de respuesta adecuado\", function () {",
              "    pm.expect(pm.response.responseSize).to.be.below(500);",
              "    console.log(`âœ“ TamaÃ±o de respuesta: ${pm.response.responseSize} bytes`);",
              "});",
              "",
              "// 10. Test de integridad del error",
              "pm.test(\"Integridad del error 400\", function () {",
              "    const criticalChecks = [",
              "        { name: \"Status 400\", check: pm.response.code === 400 },",
              "        { name: \"Es JSON\", check: responseData !== null },",
              "        { name: \"Tiene mensaje\", check: responseData && (",
              "            (responseData.title && Array.isArray(responseData.title)) ||",
              "            responseData.detail ||",
              "            responseData.message ||",
              "            Object.keys(responseData).length > 0",
              "        )}",
              "    ];",
              "    ",
              "    let allPassed = true;",
              "    criticalChecks.forEach(check => {",
              "        console.log(`${check.name}: ${check.check ? 'âœ…' : 'âŒ'}`);",
              "        if (!check.check) allPassed = false;",
              "    });",
              "    ",
              "    pm.expect(allPassed, \"Fallo una verificaciÃ³n crÃ­tica del error 400\").to.be.true;",
              "    console.log(\"âœ… Todas las verificaciones crÃ­ticas pasaron\");",
              "});",
              "",
              "// 11. InformaciÃ³n para debugging",
              "console.log(\"\\n=== RESUMEN DEL ERROR 400 ===\");",
              "console.log(\"âœ… Comportamiento esperado: No se puede crear nodo con tÃ­tulo duplicado\");",
              "console.log(\"âœ… Parent ID usado: 1 (mismo nivel)\");",
              "console.log(\"âœ… TÃ­tulo duplicado: 'Nodo para test 1'\");",
              "console.log(\"âœ… La API correctamente rechaza la creaciÃ³n duplicada\");",
              "",
              "// 12. Limpiar variable temporal si existÃ­a (opcional)",
              "if (pm.environment.get(\"intento_fallido_nodo\")) {",
              "    pm.environment.unset(\"intento_fallido_nodo\");",
              "}",
              "",
              "console.log(\"=== Test de error por duplicado completado ===\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n    \"content\": \"Nodo para test 2\",\n    \"parent\": {{CAPTURE_NODE_ID_1}}\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Node_Create_1_By_ID",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Listar Nodos RaÃ­z - API ACTUAL",
              "// Endpoint: GET /api/nodes/",
              "// ============================================",
              "",
              "console.log(\"=== Test: Listar Nodos RaÃ­z (API Django REST Actual) ===\");",
              "",
              "// 1. Verificar cÃ³digo de estado",
              "pm.test(\"Status code es 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 2. Verificar que la respuesta es JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    // Tu API podrÃ­a devolver un objeto paginado o un array directo",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. Determinar si la respuesta estÃ¡ paginada",
              "let resultsArray = null;",
              "let isPaginated = false;",
              "",
              "if (responseData) {",
              "    if (responseData.results && Array.isArray(responseData.results)) {",
              "        // Respuesta paginada (DRF con paginaciÃ³n habilitada)",
              "        resultsArray = responseData.results;",
              "        isPaginated = true;",
              "        console.log(\"âœ“ Respuesta paginada detectada\");",
              "        console.log(`  - Total nodos: ${responseData.count || resultsArray.length}`);",
              "        console.log(`  - PÃ¡gina actual: ${responseData.current_page || 1}`);",
              "    } else if (Array.isArray(responseData)) {",
              "        // Respuesta directa (array)",
              "        resultsArray = responseData;",
              "        console.log(\"âœ“ Respuesta directa (array)\");",
              "    }",
              "}",
              "",
              "// 4. Verificar estructura de los datos",
              "if (resultsArray && resultsArray.length > 0) {",
              "    const firstItem = resultsArray[0];",
              "    ",
              "    // 5. Verificar propiedades requeridas segÃºn tu serializador actual",
              "    pm.test(\"Elementos tienen estructura correcta\", function () {",
              "        // Campos segÃºn tu NodeSerializer actual",
              "        pm.expect(firstItem).to.include.all.keys(",
              "            \"id\",",
              "            \"content\",      // Campo principal",
              "            \"title\",        // Generado dinÃ¡micamente con num2words",
              "            \"parent\",       // null para raÃ­ces",
              "            \"children\",     // Array (puede estar vacÃ­o)",
              "            \"created_at\"    // Fecha formateada",
              "        );",
              "    });",
              "    ",
              "    // 6. Verificar tipos de datos",
              "    pm.test(\"Tipos de datos correctos\", function () {",
              "        pm.expect(firstItem.id).to.be.a(\"number\");",
              "        pm.expect(firstItem.content).to.be.a(\"string\");",
              "        pm.expect(firstItem.title).to.be.a(\"string\");",
              "        ",
              "        // parent debe ser null (nodos raÃ­z)",
              "        pm.expect(firstItem.parent).to.be.null;",
              "        ",
              "        // children es array",
              "        pm.expect(firstItem.children).to.be.an(\"array\");",
              "        ",
              "        // created_at es string",
              "        pm.expect(firstItem.created_at).to.be.a(\"string\");",
              "    });",
              "    ",
              "    // 7. Verificar que todos son nodos raÃ­z (parent es null)",
              "    pm.test(\"Todos los nodos son raÃ­z (parent es null)\", function () {",
              "        const allRoots = resultsArray.every(item => item.parent === null);",
              "        pm.expect(allRoots).to.be.true;",
              "    });",
              "    ",
              "    // 8. Verificar IDs Ãºnicos y positivos",
              "    pm.test(\"IDs son Ãºnicos y positivos\", function () {",
              "        const ids = resultsArray.map(item => item.id);",
              "        const uniqueIds = [...new Set(ids)];",
              "        ",
              "        pm.expect(ids.length).to.equal(uniqueIds.length, \"IDs deben ser Ãºnicos\");",
              "        pm.expect(ids.every(id => id > 0)).to.be.true;",
              "    });",
              "    ",
              "    // 9. Verificar formato de fecha (formato de tu API)",
              "    pm.test(\"Fecha created_at tiene formato vÃ¡lido\", function () {",
              "        // Formato de tu API: \"YYYY-MM-DD HH:MM:SS\" (zona horaria aplicada)",
              "        const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "        pm.expect(firstItem.created_at).to.match(dateRegex);",
              "    });",
              "    ",
              "    // 10. Verificar que content no estÃ¡ vacÃ­o",
              "    pm.test(\"Content no estÃ¡ vacÃ­o\", function () {",
              "        const allValid = resultsArray.every(item => ",
              "            item.content && item.content.trim().length > 0",
              "        );",
              "        pm.expect(allValid).to.be.true;",
              "    });",
              "    ",
              "    // 11. Verificar que title no estÃ¡ vacÃ­o (generado de num2words)",
              "    pm.test(\"Title no estÃ¡ vacÃ­o\", function () {",
              "        const allValid = resultsArray.every(item => ",
              "            item.title && item.title.trim().length > 0",
              "        );",
              "        pm.expect(allValid).to.be.true;",
              "    });",
              "    ",
              "    // 12. Verificar que children es array (puede estar vacÃ­o)",
              "    pm.test(\"Children es siempre array\", function () {",
              "        const allArrays = resultsArray.every(item => Array.isArray(item.children));",
              "        pm.expect(allArrays).to.be.true;",
              "    });",
              "    ",
              "    // 13. Mostrar informaciÃ³n para debugging",
              "    console.log(`âœ“ Encontrados ${resultsArray.length} nodos raÃ­z`);",
              "    console.log(`âœ“ Primer nodo: ID=${firstItem.id}, Content=\"${firstItem.content}\", Title=\"${firstItem.title}\"`);",
              "    ",
              "    console.log(\"Resumen de nodos raÃ­z:\");",
              "    resultsArray.slice(0, 5).forEach((nodo, index) => { // Mostrar solo primeros 5",
              "        console.log(`  ${index + 1}. ID: ${nodo.id}, Title: \"${nodo.title}\"`);",
              "    });",
              "    if (resultsArray.length > 5) {",
              "        console.log(`  ... y ${resultsArray.length - 5} mÃ¡s`);",
              "    }",
              "    ",
              "} else if (resultsArray && resultsArray.length === 0) {",
              "    // Array vacÃ­o",
              "    pm.test(\"No hay nodos raÃ­z (array vacÃ­o)\", function () {",
              "        pm.expect(resultsArray.length).to.equal(0);",
              "    });",
              "    console.log(\"âœ“ No hay nodos raÃ­z (array vacÃ­o)\");",
              "}",
              "",
              "// 14. Verificar headers de cachÃ© si aplica",
              "pm.test(\"Headers de cachÃ© si aplican\", function () {",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    const expires = pm.response.headers.get(\"Expires\");",
              "    ",
              "    if (cacheControl) {",
              "        console.log(`Cache-Control: ${cacheControl}`);",
              "        pm.expect(cacheControl).to.not.be.empty;",
              "    }",
              "    ",
              "    if (expires) {",
              "        console.log(`Expires: ${expires}`);",
              "    }",
              "});",
              "",
              "// 15. Verificar tiempo de respuesta",
              "pm.test(\"Tiempo de respuesta aceptable\", function () {",
              "    // Con cachÃ© deberÃ­a ser rÃ¡pido, pero permitimos hasta 2 segundos",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    console.log(`âœ“ Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "    ",
              "    if (pm.response.responseTime > 1000) {",
              "        console.log(\"âš  Tiempo de respuesta mayor a 1 segundo\");",
              "    }",
              "});",
              "",
              "// 16. Verificar Content-Type",
              "pm.test(\"Content-Type es application/json\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ“ Content-Type: ${contentType}`);",
              "});",
              "",
              "// 17. Verificar que no hay errores en la respuesta",
              "pm.test(\"Respuesta no contiene errores\", function () {",
              "    if (responseData) {",
              "        pm.expect(responseData).to.not.have.property(\"error\");",
              "        pm.expect(responseData).to.not.have.property(\"detail\");",
              "        ",
              "        // Verificar si hay mensaje de error disfrazado",
              "        if (responseData.message && typeof responseData.message === 'string') {",
              "            const lowerMsg = responseData.message.toLowerCase();",
              "            pm.expect(lowerMsg).to.not.include(\"error\");",
              "            pm.expect(lowerMsg).to.not.include(\"exception\");",
              "        }",
              "    }",
              "});",
              "",
              "// 18. Verificar estructura de paginaciÃ³n si aplica",
              "if (isPaginated) {",
              "    pm.test(\"Estructura de paginaciÃ³n correcta\", function () {",
              "        pm.expect(responseData).to.have.property(\"count\");",
              "        pm.expect(responseData.count).to.be.a(\"number\");",
              "        pm.expect(responseData.count).to.be.at.least(0);",
              "        ",
              "        pm.expect(responseData.results).to.be.an(\"array\");",
              "        ",
              "        // Verificar next y previous si existen",
              "        if (responseData.next !== undefined) {",
              "            pm.expect(responseData.next).to.satisfy(val => ",
              "                val === null || typeof val === 'string'",
              "            );",
              "        }",
              "        ",
              "        if (responseData.previous !== undefined) {",
              "            pm.expect(responseData.previous).to.satisfy(val => ",
              "                val === null || typeof val === 'string'",
              "            );",
              "        }",
              "    });",
              "}",
              "",
              "// 19. ValidaciÃ³n de integridad de datos",
              "if (resultsArray && resultsArray.length > 0) {",
              "    pm.test(\"Integridad de datos\", function () {",
              "        resultsArray.forEach((item, index) => {",
              "            // Campos obligatorios existen",
              "            pm.expect(item.id).to.exist.and.to.be.a('number');",
              "            pm.expect(item.content).to.exist.and.to.be.a('string');",
              "            pm.expect(item.title).to.exist.and.to.be.a('string');",
              "            pm.expect(item.created_at).to.exist.and.to.be.a('string');",
              "            ",
              "            // Valores no vacÃ­os",
              "            pm.expect(item.content.trim()).to.not.be.empty;",
              "            pm.expect(item.title.trim()).to.not.be.empty;",
              "            ",
              "            // ID positivo",
              "            pm.expect(item.id).to.be.greaterThan(0);",
              "            ",
              "            // parent debe ser null para nodos raÃ­z",
              "            pm.expect(item.parent).to.be.null;",
              "        });",
              "    });",
              "}",
              "",
              "console.log(\"=== Test completado ===\");",
              "",
              "// 20. Guardar datos para tests futuros",
              "if (resultsArray && resultsArray.length > 0) {",
              "    const firstNode = resultsArray[0];",
              "    ",
              "    pm.environment.set(\"primer_nodo_raiz_id\", firstNode.id);",
              "    pm.environment.set(\"primer_nodo_raiz_content\", firstNode.content);",
              "    pm.environment.set(\"primer_nodo_raiz_title\", firstNode.title);",
              "    pm.environment.set(\"total_nodos_raiz\", resultsArray.length);",
              "    ",
              "    // Guardar algunos IDs para tests de actualizaciÃ³n/eliminaciÃ³n",
              "    const sampleIds = resultsArray.slice(0, 3).map(node => node.id);",
              "    pm.environment.set(\"sample_node_ids\", JSON.stringify(sampleIds));",
              "    ",
              "    console.log(`âœ“ Datos guardados para tests futuros:`);",
              "    console.log(`  - Primer nodo: ID=${firstNode.id}`);",
              "    console.log(`  - Content: \"${firstNode.content}\"`);",
              "    console.log(`  - Title: \"${firstNode.title}\"`);",
              "    console.log(`  - Total: ${resultsArray.length} nodos`);",
              "}",
              "",
              "// 21. Pruebas especÃ­ficas para tu API",
              "pm.test(\"CaracterÃ­sticas especÃ­ficas de la API\", function () {",
              "    if (resultsArray && resultsArray.length > 0) {",
              "        const firstItem = resultsArray[0];",
              "        ",
              "        // Verificar que title no es numÃ©rico (es num2words)",
              "        const title = firstItem.title;",
              "        const isNumeric = /^\\d+$/.test(title);",
              "        pm.expect(isNumeric).to.be.false;",
              "        ",
              "        // Verificar que content y title son diferentes",
              "        pm.expect(firstItem.content).to.not.equal(firstItem.title);",
              "        ",
              "        // Verificar formato de fecha especÃ­fico",
              "        const dateMatch = firstItem.created_at.match(/^(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/);",
              "        pm.expect(dateMatch).to.not.be.null;",
              "        ",
              "        if (dateMatch) {",
              "            const [, year, month, day, hour, minute, second] = dateMatch;",
              "            // Validaciones bÃ¡sicas de fecha",
              "            pm.expect(parseInt(month)).to.be.within(1, 12);",
              "            pm.expect(parseInt(day)).to.be.within(1, 31);",
              "            pm.expect(parseInt(hour)).to.be.within(0, 23);",
              "            pm.expect(parseInt(minute)).to.be.within(0, 59);",
              "            pm.expect(parseInt(second)).to.be.within(0, 59);",
              "        }",
              "    }",
              "});",
              "",
              "// 22. Verificar parÃ¡metros de consulta si existen",
              "const url = pm.request.url.toString();",
              "if (url.includes(\"?\")) {",
              "    pm.test(\"ParÃ¡metros de consulta procesados\", function () {",
              "        console.log(`URL con parÃ¡metros: ${url}`);",
              "        ",
              "        // Verificar parÃ¡metros especÃ­ficos",
              "        if (url.includes(\"depth=\")) {",
              "            console.log(\"âœ“ ParÃ¡metro 'depth' detectado\");",
              "        }",
              "        if (url.includes(\"search=\")) {",
              "            console.log(\"âœ“ ParÃ¡metro 'search' detectado\");",
              "        }",
              "        if (url.includes(\"ordering=\")) {",
              "            console.log(\"âœ“ ParÃ¡metro 'ordering' detectado\");",
              "        }",
              "    });",
              "}",
              "",
              "// 23. Verificar headers personalizados",
              "pm.test(\"Headers personalizados\", function () {",
              "    const acceptLanguage = pm.request.headers.get(\"Accept-Language\");",
              "    const timeZone = pm.request.headers.get(\"Time-Zone\");",
              "    ",
              "    if (acceptLanguage) {",
              "        console.log(`âœ“ Accept-Language enviado: ${acceptLanguage}`);",
              "        // Tu API usa esto para generar title en el idioma correcto",
              "    }",
              "    ",
              "    if (timeZone) {",
              "        console.log(`âœ“ Time-Zone enviado: ${timeZone}`);",
              "        // Tu API usa esto para formatear created_at",
              "    }",
              "});",
              "",
              "// 24. Verificar autenticaciÃ³n si aplica",
              "const authHeader = pm.request.headers.get(\"Authorization\");",
              "if (authHeader) {",
              "    console.log(`âœ“ AutenticaciÃ³n detectada: ${authHeader.substring(0, 20)}...`);",
              "} else {",
              "    console.log(\"âš  Sin autenticaciÃ³n - asegÃºrate que tu endpoint no la requiera\");",
              "}",
              "",
              "// 25. Verificar tamaÃ±o de respuesta",
              "pm.test(\"TamaÃ±o de respuesta razonable\", function () {",
              "    const responseSize = pm.response.responseSize;",
              "    console.log(`âœ“ TamaÃ±o de respuesta: ${responseSize} bytes`);",
              "    ",
              "    // Para una lista de nodos, tamaÃ±o razonable",
              "    if (responseSize > 102400) { // 100KB",
              "        console.log(\"âš  Respuesta mayor a 100KB - revisar si hay datos excesivos\");",
              "    }",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_1}}",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_1}}"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get_Node_Create_2_By_ID",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Listar Nodos RaÃ­z - API ACTUAL",
              "// Endpoint: GET /api/nodes/",
              "// ============================================",
              "",
              "console.log(\"=== Test: Listar Nodos RaÃ­z (API Django REST Actual) ===\");",
              "",
              "// 1. Verificar cÃ³digo de estado",
              "pm.test(\"Status code es 200\", function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// 2. Verificar que la respuesta es JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    // Tu API podrÃ­a devolver un objeto paginado o un array directo",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. Determinar si la respuesta estÃ¡ paginada",
              "let resultsArray = null;",
              "let isPaginated = false;",
              "",
              "if (responseData) {",
              "    if (responseData.results && Array.isArray(responseData.results)) {",
              "        // Respuesta paginada (DRF con paginaciÃ³n habilitada)",
              "        resultsArray = responseData.results;",
              "        isPaginated = true;",
              "        console.log(\"âœ“ Respuesta paginada detectada\");",
              "        console.log(`  - Total nodos: ${responseData.count || resultsArray.length}`);",
              "        console.log(`  - PÃ¡gina actual: ${responseData.current_page || 1}`);",
              "    } else if (Array.isArray(responseData)) {",
              "        // Respuesta directa (array)",
              "        resultsArray = responseData;",
              "        console.log(\"âœ“ Respuesta directa (array)\");",
              "    }",
              "}",
              "",
              "// 4. Verificar estructura de los datos",
              "if (resultsArray && resultsArray.length > 0) {",
              "    const firstItem = resultsArray[0];",
              "    ",
              "    // 5. Verificar propiedades requeridas segÃºn tu serializador actual",
              "    pm.test(\"Elementos tienen estructura correcta\", function () {",
              "        // Campos segÃºn tu NodeSerializer actual",
              "        pm.expect(firstItem).to.include.all.keys(",
              "            \"id\",",
              "            \"content\",      // Campo principal",
              "            \"title\",        // Generado dinÃ¡micamente con num2words",
              "            \"parent\",       // null para raÃ­ces",
              "            \"children\",     // Array (puede estar vacÃ­o)",
              "            \"created_at\"    // Fecha formateada",
              "        );",
              "    });",
              "    ",
              "    // 6. Verificar tipos de datos",
              "    pm.test(\"Tipos de datos correctos\", function () {",
              "        pm.expect(firstItem.id).to.be.a(\"number\");",
              "        pm.expect(firstItem.content).to.be.a(\"string\");",
              "        pm.expect(firstItem.title).to.be.a(\"string\");",
              "        ",
              "        // parent debe ser null (nodos raÃ­z)",
              "        pm.expect(firstItem.parent).to.be.null;",
              "        ",
              "        // children es array",
              "        pm.expect(firstItem.children).to.be.an(\"array\");",
              "        ",
              "        // created_at es string",
              "        pm.expect(firstItem.created_at).to.be.a(\"string\");",
              "    });",
              "    ",
              "    // 7. Verificar que todos son nodos raÃ­z (parent es null)",
              "    pm.test(\"Todos los nodos son raÃ­z (parent es null)\", function () {",
              "        const allRoots = resultsArray.every(item => item.parent === null);",
              "        pm.expect(allRoots).to.be.true;",
              "    });",
              "    ",
              "    // 8. Verificar IDs Ãºnicos y positivos",
              "    pm.test(\"IDs son Ãºnicos y positivos\", function () {",
              "        const ids = resultsArray.map(item => item.id);",
              "        const uniqueIds = [...new Set(ids)];",
              "        ",
              "        pm.expect(ids.length).to.equal(uniqueIds.length, \"IDs deben ser Ãºnicos\");",
              "        pm.expect(ids.every(id => id > 0)).to.be.true;",
              "    });",
              "    ",
              "    // 9. Verificar formato de fecha (formato de tu API)",
              "    pm.test(\"Fecha created_at tiene formato vÃ¡lido\", function () {",
              "        // Formato de tu API: \"YYYY-MM-DD HH:MM:SS\" (zona horaria aplicada)",
              "        const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;",
              "        pm.expect(firstItem.created_at).to.match(dateRegex);",
              "    });",
              "    ",
              "    // 10. Verificar que content no estÃ¡ vacÃ­o",
              "    pm.test(\"Content no estÃ¡ vacÃ­o\", function () {",
              "        const allValid = resultsArray.every(item => ",
              "            item.content && item.content.trim().length > 0",
              "        );",
              "        pm.expect(allValid).to.be.true;",
              "    });",
              "    ",
              "    // 11. Verificar que title no estÃ¡ vacÃ­o (generado de num2words)",
              "    pm.test(\"Title no estÃ¡ vacÃ­o\", function () {",
              "        const allValid = resultsArray.every(item => ",
              "            item.title && item.title.trim().length > 0",
              "        );",
              "        pm.expect(allValid).to.be.true;",
              "    });",
              "    ",
              "    // 12. Verificar que children es array (puede estar vacÃ­o)",
              "    pm.test(\"Children es siempre array\", function () {",
              "        const allArrays = resultsArray.every(item => Array.isArray(item.children));",
              "        pm.expect(allArrays).to.be.true;",
              "    });",
              "    ",
              "    // 13. Mostrar informaciÃ³n para debugging",
              "    console.log(`âœ“ Encontrados ${resultsArray.length} nodos raÃ­z`);",
              "    console.log(`âœ“ Primer nodo: ID=${firstItem.id}, Content=\"${firstItem.content}\", Title=\"${firstItem.title}\"`);",
              "    ",
              "    console.log(\"Resumen de nodos raÃ­z:\");",
              "    resultsArray.slice(0, 5).forEach((nodo, index) => { // Mostrar solo primeros 5",
              "        console.log(`  ${index + 1}. ID: ${nodo.id}, Title: \"${nodo.title}\"`);",
              "    });",
              "    if (resultsArray.length > 5) {",
              "        console.log(`  ... y ${resultsArray.length - 5} mÃ¡s`);",
              "    }",
              "    ",
              "} else if (resultsArray && resultsArray.length === 0) {",
              "    // Array vacÃ­o",
              "    pm.test(\"No hay nodos raÃ­z (array vacÃ­o)\", function () {",
              "        pm.expect(resultsArray.length).to.equal(0);",
              "    });",
              "    console.log(\"âœ“ No hay nodos raÃ­z (array vacÃ­o)\");",
              "}",
              "",
              "// 14. Verificar headers de cachÃ© si aplica",
              "pm.test(\"Headers de cachÃ© si aplican\", function () {",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    const expires = pm.response.headers.get(\"Expires\");",
              "    ",
              "    if (cacheControl) {",
              "        console.log(`Cache-Control: ${cacheControl}`);",
              "        pm.expect(cacheControl).to.not.be.empty;",
              "    }",
              "    ",
              "    if (expires) {",
              "        console.log(`Expires: ${expires}`);",
              "    }",
              "});",
              "",
              "// 15. Verificar tiempo de respuesta",
              "pm.test(\"Tiempo de respuesta aceptable\", function () {",
              "    // Con cachÃ© deberÃ­a ser rÃ¡pido, pero permitimos hasta 2 segundos",
              "    pm.expect(pm.response.responseTime).to.be.below(2000);",
              "    console.log(`âœ“ Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "    ",
              "    if (pm.response.responseTime > 1000) {",
              "        console.log(\"âš  Tiempo de respuesta mayor a 1 segundo\");",
              "    }",
              "});",
              "",
              "// 16. Verificar Content-Type",
              "pm.test(\"Content-Type es application/json\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ“ Content-Type: ${contentType}`);",
              "});",
              "",
              "// 17. Verificar que no hay errores en la respuesta",
              "pm.test(\"Respuesta no contiene errores\", function () {",
              "    if (responseData) {",
              "        pm.expect(responseData).to.not.have.property(\"error\");",
              "        pm.expect(responseData).to.not.have.property(\"detail\");",
              "        ",
              "        // Verificar si hay mensaje de error disfrazado",
              "        if (responseData.message && typeof responseData.message === 'string') {",
              "            const lowerMsg = responseData.message.toLowerCase();",
              "            pm.expect(lowerMsg).to.not.include(\"error\");",
              "            pm.expect(lowerMsg).to.not.include(\"exception\");",
              "        }",
              "    }",
              "});",
              "",
              "// 18. Verificar estructura de paginaciÃ³n si aplica",
              "if (isPaginated) {",
              "    pm.test(\"Estructura de paginaciÃ³n correcta\", function () {",
              "        pm.expect(responseData).to.have.property(\"count\");",
              "        pm.expect(responseData.count).to.be.a(\"number\");",
              "        pm.expect(responseData.count).to.be.at.least(0);",
              "        ",
              "        pm.expect(responseData.results).to.be.an(\"array\");",
              "        ",
              "        // Verificar next y previous si existen",
              "        if (responseData.next !== undefined) {",
              "            pm.expect(responseData.next).to.satisfy(val => ",
              "                val === null || typeof val === 'string'",
              "            );",
              "        }",
              "        ",
              "        if (responseData.previous !== undefined) {",
              "            pm.expect(responseData.previous).to.satisfy(val => ",
              "                val === null || typeof val === 'string'",
              "            );",
              "        }",
              "    });",
              "}",
              "",
              "// 19. ValidaciÃ³n de integridad de datos",
              "if (resultsArray && resultsArray.length > 0) {",
              "    pm.test(\"Integridad de datos\", function () {",
              "        resultsArray.forEach((item, index) => {",
              "            // Campos obligatorios existen",
              "            pm.expect(item.id).to.exist.and.to.be.a('number');",
              "            pm.expect(item.content).to.exist.and.to.be.a('string');",
              "            pm.expect(item.title).to.exist.and.to.be.a('string');",
              "            pm.expect(item.created_at).to.exist.and.to.be.a('string');",
              "            ",
              "            // Valores no vacÃ­os",
              "            pm.expect(item.content.trim()).to.not.be.empty;",
              "            pm.expect(item.title.trim()).to.not.be.empty;",
              "            ",
              "            // ID positivo",
              "            pm.expect(item.id).to.be.greaterThan(0);",
              "            ",
              "            // parent debe ser null para nodos raÃ­z",
              "            pm.expect(item.parent).to.be.null;",
              "        });",
              "    });",
              "}",
              "",
              "console.log(\"=== Test completado ===\");",
              "",
              "// 20. Guardar datos para tests futuros",
              "if (resultsArray && resultsArray.length > 0) {",
              "    const firstNode = resultsArray[0];",
              "    ",
              "    pm.environment.set(\"primer_nodo_raiz_id\", firstNode.id);",
              "    pm.environment.set(\"primer_nodo_raiz_content\", firstNode.content);",
              "    pm.environment.set(\"primer_nodo_raiz_title\", firstNode.title);",
              "    pm.environment.set(\"total_nodos_raiz\", resultsArray.length);",
              "    ",
              "    // Guardar algunos IDs para tests de actualizaciÃ³n/eliminaciÃ³n",
              "    const sampleIds = resultsArray.slice(0, 3).map(node => node.id);",
              "    pm.environment.set(\"sample_node_ids\", JSON.stringify(sampleIds));",
              "    ",
              "    console.log(`âœ“ Datos guardados para tests futuros:`);",
              "    console.log(`  - Primer nodo: ID=${firstNode.id}`);",
              "    console.log(`  - Content: \"${firstNode.content}\"`);",
              "    console.log(`  - Title: \"${firstNode.title}\"`);",
              "    console.log(`  - Total: ${resultsArray.length} nodos`);",
              "}",
              "",
              "// 21. Pruebas especÃ­ficas para tu API",
              "pm.test(\"CaracterÃ­sticas especÃ­ficas de la API\", function () {",
              "    if (resultsArray && resultsArray.length > 0) {",
              "        const firstItem = resultsArray[0];",
              "        ",
              "        // Verificar que title no es numÃ©rico (es num2words)",
              "        const title = firstItem.title;",
              "        const isNumeric = /^\\d+$/.test(title);",
              "        pm.expect(isNumeric).to.be.false;",
              "        ",
              "        // Verificar que content y title son diferentes",
              "        pm.expect(firstItem.content).to.not.equal(firstItem.title);",
              "        ",
              "        // Verificar formato de fecha especÃ­fico",
              "        const dateMatch = firstItem.created_at.match(/^(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/);",
              "        pm.expect(dateMatch).to.not.be.null;",
              "        ",
              "        if (dateMatch) {",
              "            const [, year, month, day, hour, minute, second] = dateMatch;",
              "            // Validaciones bÃ¡sicas de fecha",
              "            pm.expect(parseInt(month)).to.be.within(1, 12);",
              "            pm.expect(parseInt(day)).to.be.within(1, 31);",
              "            pm.expect(parseInt(hour)).to.be.within(0, 23);",
              "            pm.expect(parseInt(minute)).to.be.within(0, 59);",
              "            pm.expect(parseInt(second)).to.be.within(0, 59);",
              "        }",
              "    }",
              "});",
              "",
              "// 22. Verificar parÃ¡metros de consulta si existen",
              "const url = pm.request.url.toString();",
              "if (url.includes(\"?\")) {",
              "    pm.test(\"ParÃ¡metros de consulta procesados\", function () {",
              "        console.log(`URL con parÃ¡metros: ${url}`);",
              "        ",
              "        // Verificar parÃ¡metros especÃ­ficos",
              "        if (url.includes(\"depth=\")) {",
              "            console.log(\"âœ“ ParÃ¡metro 'depth' detectado\");",
              "        }",
              "        if (url.includes(\"search=\")) {",
              "            console.log(\"âœ“ ParÃ¡metro 'search' detectado\");",
              "        }",
              "        if (url.includes(\"ordering=\")) {",
              "            console.log(\"âœ“ ParÃ¡metro 'ordering' detectado\");",
              "        }",
              "    });",
              "}",
              "",
              "// 23. Verificar headers personalizados",
              "pm.test(\"Headers personalizados\", function () {",
              "    const acceptLanguage = pm.request.headers.get(\"Accept-Language\");",
              "    const timeZone = pm.request.headers.get(\"Time-Zone\");",
              "    ",
              "    if (acceptLanguage) {",
              "        console.log(`âœ“ Accept-Language enviado: ${acceptLanguage}`);",
              "        // Tu API usa esto para generar title en el idioma correcto",
              "    }",
              "    ",
              "    if (timeZone) {",
              "        console.log(`âœ“ Time-Zone enviado: ${timeZone}`);",
              "        // Tu API usa esto para formatear created_at",
              "    }",
              "});",
              "",
              "// 24. Verificar autenticaciÃ³n si aplica",
              "const authHeader = pm.request.headers.get(\"Authorization\");",
              "if (authHeader) {",
              "    console.log(`âœ“ AutenticaciÃ³n detectada: ${authHeader.substring(0, 20)}...`);",
              "} else {",
              "    console.log(\"âš  Sin autenticaciÃ³n - asegÃºrate que tu endpoint no la requiera\");",
              "}",
              "",
              "// 25. Verificar tamaÃ±o de respuesta",
              "pm.test(\"TamaÃ±o de respuesta razonable\", function () {",
              "    const responseSize = pm.response.responseSize;",
              "    console.log(`âœ“ TamaÃ±o de respuesta: ${responseSize} bytes`);",
              "    ",
              "    // Para una lista de nodos, tamaÃ±o razonable",
              "    if (responseSize > 102400) { // 100KB",
              "        console.log(\"âš  Respuesta mayor a 100KB - revisar si hay datos excesivos\");",
              "    }",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_2}}",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_2}}"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Patch_Tittle_Node_Create_1",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Actualizar nodo (PATCH)",
              "// Endpoint: PATCH /api/nodes/{id}/",
              "// Solo actualiza el content (no hay campo title separado en tu API)",
              "// ============================================",
              "",
              "console.log(\"=== Test: Actualizar Nodo (PATCH) ===\");",
              "",
              "// 1. Verificar status code 200 OK o 201 Created",
              "pm.test(\"Status code es exitoso\", function () {",
              "    // Tu API puede devolver 200 OK o 201 Created",
              "    const validStatuses = [200, 201];",
              "    pm.expect(validStatuses).to.include(pm.response.code);",
              "    console.log(`âœ… Status code: ${pm.response.code}`);",
              "});",
              "",
              "// 2. Parsear respuesta JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. DEBUG: Mostrar quÃ© se enviÃ³ en el request",
              "const requestBody = JSON.parse(pm.request.body.raw || \"{}\");",
              "console.log(`DEBUG - Request body enviado:`);",
              "console.log(`  content: \"${requestBody.content || '(no enviado)'}\"`);",
              "console.log(`  parent: ${requestBody.parent || \"(no enviado)\"}`);",
              "",
              "// 4. Verificar estructura del nodo actualizado",
              "if (responseData) {",
              "    pm.test(\"Nodo actualizado tiene estructura completa\", function () {",
              "        // Tu API devuelve estos campos en NodeSerializer",
              "        pm.expect(responseData).to.include.all.keys([",
              "            \"id\",",
              "            \"content\",      // Este es el campo que actualizamos",
              "            \"title\",        // Generado automÃ¡ticamente del ID con num2words",
              "            \"parent\",",
              "            \"children\",",
              "            \"created_at\"",
              "        ]);",
              "        console.log(\"âœ… Estructura de respuesta vÃ¡lida\");",
              "    });",
              "    ",
              "    // 5. Verificar que el content se actualizÃ³ correctamente (si se enviÃ³)",
              "    if (requestBody.content !== undefined) {",
              "        pm.test(\"Content fue actualizado si se enviÃ³\", function () {",
              "            pm.expect(responseData.content).to.equal(requestBody.content);",
              "            console.log(`âœ… Content actualizado a: \"${responseData.content}\"`);",
              "        });",
              "    }",
              "    ",
              "    // 6. Verificar que el ID NO cambiÃ³",
              "    const requestUrl = pm.request.url.toString();",
              "    const urlParts = requestUrl.split('/');",
              "    const requestedId = parseInt(urlParts[urlParts.length - 2]);",
              "    ",
              "    pm.test(\"ID del nodo permanece igual\", function () {",
              "        pm.expect(responseData.id).to.equal(requestedId);",
              "        console.log(`âœ… ID permanece: ${responseData.id}`);",
              "    });",
              "    ",
              "    // 7. Verificar que el parent NO cambiÃ³ (a menos que se haya enviado)",
              "    pm.test(\"Parent solo cambia si se especifica\", function () {",
              "        if (requestBody.parent !== undefined) {",
              "            // Si se enviÃ³ parent, debe actualizarse",
              "            pm.expect(responseData.parent).to.equal(requestBody.parent);",
              "            console.log(`âœ… Parent actualizado a: ${responseData.parent}`);",
              "        } else {",
              "            // Si no se enviÃ³ parent, debe permanecer igual",
              "            const originalParent = pm.environment.get(\"original_parent_before_update\");",
              "            if (originalParent) {",
              "                const expectedParent = originalParent === \"null\" ? null : parseInt(originalParent);",
              "                pm.expect(responseData.parent).to.equal(expectedParent);",
              "                console.log(`âœ… Parent permanece: ${responseData.parent}`);",
              "            }",
              "        }",
              "    });",
              "    ",
              "    // 8. Verificar que title fue regenerado automÃ¡ticamente",
              "    pm.test(\"Title fue regenerado automÃ¡ticamente\", function () {",
              "        // Title se genera del ID con num2words, no se puede actualizar directamente",
              "        pm.expect(responseData.title).to.be.a(\"string\");",
              "        pm.expect(responseData.title.trim().length).to.be.greaterThan(0);",
              "        ",
              "        // Title no debe ser igual al content (a menos que coincidan por casualidad)",
              "        if (responseData.content !== responseData.title) {",
              "            pm.expect(responseData.content).to.not.equal(responseData.title);",
              "        }",
              "        ",
              "        // Title no debe ser numÃ©rico (es num2words)",
              "        const isNumeric = /^\\d+$/.test(responseData.title);",
              "        pm.expect(isNumeric).to.be.false;",
              "        ",
              "        console.log(`âœ… Title regenerado: \"${responseData.title}\"`);",
              "    });",
              "    ",
              "    // 9. Verificar que children sigue siendo array",
              "    pm.test(\"Children sigue siendo array\", function () {",
              "        pm.expect(responseData.children).to.be.an(\"array\");",
              "        console.log(`âœ… Children sigue siendo array con ${responseData.children.length} elementos`);",
              "    });",
              "    ",
              "    // 10. Verificar que created_at NO cambiÃ³",
              "    pm.test(\"Fecha de creaciÃ³n permanece igual\", function () {",
              "        const originalCreatedAt = pm.environment.get(\"original_created_at_before_update\");",
              "        if (originalCreatedAt) {",
              "            pm.expect(responseData.created_at).to.equal(originalCreatedAt);",
              "        } else {",
              "            // Al menos verificar formato",
              "            pm.expect(responseData.created_at).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);",
              "        }",
              "        console.log(`âœ… Created_at permanece: ${responseData.created_at}`);",
              "    });",
              "    ",
              "    // 11. Verificar que los campos no enviados permanecen iguales",
              "    pm.test(\"Campos no especificados permanecen iguales\", function () {",
              "        // Si no enviamos content, deberÃ­a permanecer igual",
              "        if (requestBody.content === undefined) {",
              "            const originalContent = pm.environment.get(\"original_content_before_update\");",
              "            if (originalContent) {",
              "                pm.expect(responseData.content).to.equal(originalContent);",
              "            }",
              "        }",
              "        ",
              "        // Si no enviamos parent, deberÃ­a permanecer igual",
              "        if (requestBody.parent === undefined) {",
              "            const originalParent = pm.environment.get(\"original_parent_before_update\");",
              "            if (originalParent) {",
              "                const expectedParent = originalParent === \"null\" ? null : parseInt(originalParent);",
              "                pm.expect(responseData.parent).to.equal(expectedParent);",
              "            }",
              "        }",
              "    });",
              "}",
              "",
              "// 12. Verificar headers de respuesta",
              "pm.test(\"Headers de respuesta correctos\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ… Content-Type: ${contentType}`);",
              "});",
              "",
              "// 13. Verificar tiempo de respuesta",
              "pm.test(\"Tiempo de respuesta aceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(1000);",
              "    console.log(`âœ… Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "    ",
              "    if (pm.response.responseTime > 500) {",
              "        console.log(\"âš  Tiempo de respuesta mayor a 500ms\");",
              "    }",
              "});",
              "",
              "// 14. Verificar que no hay errores en la respuesta",
              "pm.test(\"Respuesta no contiene errores\", function () {",
              "    if (responseData) {",
              "        pm.expect(responseData).to.not.have.property(\"error\");",
              "        pm.expect(responseData).to.not.have.property(\"detail\");",
              "        pm.expect(responseData).to.not.have.property(\"non_field_errors\");",
              "    }",
              "});",
              "",
              "// 15. Validaciones adicionales de integridad",
              "if (responseData) {",
              "    pm.test(\"Integridad de datos despuÃ©s de actualizar\", function () {",
              "        // ID debe ser positivo",
              "        pm.expect(responseData.id).to.be.greaterThan(0);",
              "        ",
              "        // Content no debe estar vacÃ­o",
              "        pm.expect(responseData.content.trim().length).to.be.greaterThan(0);",
              "        ",
              "        // Title no debe estar vacÃ­o",
              "        pm.expect(responseData.title.trim().length).to.be.greaterThan(0);",
              "        ",
              "        // Children debe ser array",
              "        pm.expect(Array.isArray(responseData.children)).to.be.true;",
              "        ",
              "        // Formato de fecha vÃ¡lido",
              "        pm.expect(responseData.created_at).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);",
              "    });",
              "}",
              "",
              "// 16. RESUMEN FINAL",
              "if (responseData) {",
              "    console.log(\"\\n\" + \"=\".repeat(60));",
              "    console.log(\"âœ… NODO ACTUALIZADO EXITOSAMENTE\");",
              "    console.log(\"=\".repeat(60));",
              "    console.log(`Nodo ID: ${responseData.id}`);",
              "    ",
              "    // Mostrar content anterior si estÃ¡ disponible",
              "    const originalContent = pm.environment.get(\"original_content_before_update\");",
              "    if (originalContent && requestBody.content !== undefined) {",
              "        console.log(`Content anterior: \"${originalContent}\"`);",
              "        console.log(`Content nuevo: \"${responseData.content}\"`);",
              "    } else {",
              "        console.log(`Content: \"${responseData.content}\"`);",
              "    }",
              "    ",
              "    // Mostrar title (siempre generado automÃ¡ticamente)",
              "    console.log(`Title (automÃ¡tico): \"${responseData.title}\"`);",
              "    ",
              "    // Mostrar parent",
              "    if (responseData.parent === null) {",
              "        console.log(`Parent: RaÃ­z (null)`);",
              "    } else {",
              "        console.log(`Parent: ${responseData.parent}`);",
              "    }",
              "    ",
              "    // Mostrar children",
              "    console.log(`Hijos: ${responseData.children.length} nodos`);",
              "    ",
              "    // Mostrar fecha",
              "    console.log(`Creado: ${responseData.created_at}`);",
              "    console.log(\"=\".repeat(60));",
              "    ",
              "    // Guardar datos para posibles tests futuros",
              "    pm.environment.set(\"last_updated_node_id\", responseData.id.toString());",
              "    pm.environment.set(\"last_updated_node_content\", responseData.content);",
              "    ",
              "    // Limpiar variables temporales si es necesario",
              "    pm.environment.unset(\"original_content_before_update\");",
              "    pm.environment.unset(\"original_parent_before_update\");",
              "    pm.environment.unset(\"original_created_at_before_update\");",
              "}",
              "",
              "console.log(\"=== Test de actualizaciÃ³n de nodo completado ===\");",
              "",
              "// 17. PRE-REQUEST SCRIPT (para copiar y usar en la pestaÃ±a Pre-request Script)",
              "console.log(\"\\nâš  INSTRUCCIONES PARA PRE-REQUEST SCRIPT:\");",
              "console.log(\"Para que este test funcione correctamente, necesitas un Pre-request Script\");",
              "console.log(\"que guarde el estado original del nodo antes de actualizarlo.\");",
              "console.log(\"\\nCopia esto en la pestaÃ±a 'Pre-request Script':\");",
              "console.log(`",
              "// Pre-request Script para guardar estado original del nodo",
              "const nodeId = pm.request.url.path[pm.request.url.path.length - 2];",
              "const getNodeUrl = \\`{{base_url}}/api/nodes/\\${nodeId}/\\`;",
              "",
              "// Obtener el nodo actual para guardar su estado",
              "pm.sendRequest({",
              "    url: getNodeUrl,",
              "    method: 'GET',",
              "    headers: {",
              "        'Authorization': pm.request.headers.get('Authorization')",
              "    }",
              "}, function (err, res) {",
              "    if (!err && res.code === 200) {",
              "        const node = res.json();",
              "        pm.environment.set(\"original_content_before_update\", node.content);",
              "        pm.environment.set(\"original_parent_before_update\", node.parent === null ? \"null\" : node.parent.toString());",
              "        pm.environment.set(\"original_created_at_before_update\", node.created_at);",
              "        ",
              "        console.log(\\`âœ“ Estado original guardado para nodo \\${nodeId}\\`);",
              "        console.log(\\`  Content: \"\\${node.content}\"\\`);",
              "        console.log(\\`  Parent: \\${node.parent}\\`);",
              "    } else {",
              "        console.log(\\`âš  No se pudo obtener estado original del nodo \\${nodeId}\\`);",
              "    }",
              "});",
              "`);"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "PUT",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"content\": \"Nuevo Titulo para el nodo {{CAPTURE_NODE_ID_1}}\"\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_1}}/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_1}}",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Patch_ID_Node_Create_1",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Cambiar parent ID de un nodo (mover nodo)",
              "// Endpoint: PATCH /api/nodes/{id}/",
              "// Solo cambia el parent, mantiene el content",
              "// ============================================",
              "",
              "console.log(\"=== Test: Cambiar Parent ID (Mover Nodo) ===\");",
              "",
              "// 1. Verificar status code 200 OK",
              "pm.test(\"Status code es exitoso\", function () {",
              "    const validStatuses = [200, 201];",
              "    pm.expect(validStatuses).to.include(pm.response.code);",
              "    console.log(`âœ… Status code: ${pm.response.code}`);",
              "});",
              "",
              "// 2. Parsear respuesta JSON",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Respuesta es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. DEBUG: Mostrar quÃ© se enviÃ³ en el request",
              "const requestBody = JSON.parse(pm.request.body.raw || \"{}\");",
              "console.log(`DEBUG - Request body enviado:`);",
              "console.log(`  content: \"${requestBody.content || '(no enviado)'}\"`);",
              "console.log(`  parent: ${requestBody.parent !== undefined ? requestBody.parent : \"(no enviado)\"}`);",
              "",
              "// 4. Verificar estructura del nodo actualizado",
              "if (responseData) {",
              "    pm.test(\"Nodo actualizado tiene estructura completa\", function () {",
              "        // Estructura segÃºn tu NodeSerializer",
              "        pm.expect(responseData).to.include.all.keys([",
              "            \"id\",",
              "            \"content\",      // Campo principal",
              "            \"title\",        // Generado automÃ¡ticamente del ID",
              "            \"parent\",       // Campo que estamos cambiando",
              "            \"children\",     // Array de hijos",
              "            \"created_at\"    // Fecha de creaciÃ³n",
              "        ]);",
              "        console.log(\"âœ… Estructura de respuesta vÃ¡lida\");",
              "    });",
              "    ",
              "    // 5. Verificar que el parent se actualizÃ³ correctamente",
              "    pm.test(\"Parent fue actualizado\", function () {",
              "        // Si enviamos null, debe ser null",
              "        if (requestBody.parent === null) {",
              "            pm.expect(responseData.parent).to.be.null;",
              "        } ",
              "        // Si enviamos un nÃºmero, debe ser ese nÃºmero",
              "        else if (typeof requestBody.parent === 'number') {",
              "            pm.expect(responseData.parent).to.equal(requestBody.parent);",
              "        }",
              "        console.log(`âœ… Parent actualizado a: ${responseData.parent}`);",
              "    });",
              "    ",
              "    // 6. Verificar que el content NO cambiÃ³ (si no se enviÃ³)",
              "    if (requestBody.content === undefined) {",
              "        pm.test(\"Content permanece igual si no se especifica\", function () {",
              "            const originalContent = pm.environment.get(\"original_content_before_move\");",
              "            if (originalContent) {",
              "                pm.expect(responseData.content).to.equal(originalContent);",
              "                console.log(`âœ… Content permanece: \"${responseData.content}\"`);",
              "            }",
              "        });",
              "    }",
              "    ",
              "    // 7. Verificar que el title fue regenerado automÃ¡ticamente",
              "    pm.test(\"Title fue regenerado automÃ¡ticamente\", function () {",
              "        pm.expect(responseData.title).to.be.a(\"string\");",
              "        pm.expect(responseData.title.trim().length).to.be.greaterThan(0);",
              "        ",
              "        // Title no debe ser numÃ©rico (es num2words)",
              "        const isNumeric = /^\\d+$/.test(responseData.title);",
              "        pm.expect(isNumeric).to.be.false;",
              "        ",
              "        console.log(`âœ… Title regenerado: \"${responseData.title}\"`);",
              "    });",
              "    ",
              "    // 8. Verificar que el ID NO cambiÃ³",
              "    const requestUrl = pm.request.url.toString();",
              "    const urlParts = requestUrl.split('/');",
              "    const requestedId = parseInt(urlParts[urlParts.length - 2]);",
              "    ",
              "    pm.test(\"ID del nodo permanece igual\", function () {",
              "        pm.expect(responseData.id).to.equal(requestedId);",
              "        console.log(`âœ… ID permanece: ${responseData.id}`);",
              "    });",
              "    ",
              "    // 9. Verificar que children sigue siendo array",
              "    pm.test(\"Children sigue siendo array\", function () {",
              "        pm.expect(responseData.children).to.be.an(\"array\");",
              "        console.log(`âœ… Children es array con ${responseData.children.length} elementos`);",
              "    });",
              "    ",
              "    // 10. Verificar que created_at NO cambiÃ³",
              "    pm.test(\"Fecha de creaciÃ³n permanece igual\", function () {",
              "        const originalCreatedAt = pm.environment.get(\"original_created_at_before_move\");",
              "        if (originalCreatedAt) {",
              "            pm.expect(responseData.created_at).to.equal(originalCreatedAt);",
              "        } else {",
              "            // Al menos verificar formato",
              "            pm.expect(responseData.created_at).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);",
              "        }",
              "        console.log(`âœ… Created_at permanece: ${responseData.created_at}`);",
              "    });",
              "    ",
              "    // 11. Verificar que el nuevo parent es vÃ¡lido (si no es null)",
              "    if (responseData.parent !== null) {",
              "        pm.test(\"Nuevo parent es vÃ¡lido\", function () {",
              "            pm.expect(responseData.parent).to.be.a(\"number\");",
              "            pm.expect(responseData.parent).to.be.greaterThan(0);",
              "            pm.expect(Number.isInteger(responseData.parent)).to.be.true;",
              "        });",
              "    }",
              "    ",
              "    // 12. Verificar que no se moviÃ³ a sÃ­ mismo (no ciclos)",
              "    pm.test(\"No hay ciclo (parent no es el mismo nodo)\", function () {",
              "        pm.expect(responseData.parent).to.not.equal(responseData.id);",
              "        console.log(`âœ… No hay auto-referencia (parent â‰  ID)`);",
              "    });",
              "    ",
              "    // 13. Verificar que no se moviÃ³ a un hijo (no ciclos en Ã¡rbol)",
              "    const originalChildrenIds = JSON.parse(pm.environment.get(\"original_children_ids_before_move\") || \"[]\");",
              "    if (originalChildrenIds.length > 0 && requestBody.parent !== null) {",
              "        pm.test(\"No se moviÃ³ a un hijo directo\", function () {",
              "            pm.expect(originalChildrenIds).to.not.include(requestBody.parent);",
              "            console.log(`âœ… No se moviÃ³ a un hijo existente`);",
              "        });",
              "    }",
              "    ",
              "    // 14. Verificar reglas de negocio adicionales",
              "    pm.test(\"Validaciones de integridad\", function () {",
              "        // Si el nodo tiene hijos y se mueve, sus hijos deben mantenerse",
              "        const originalHasChildren = pm.environment.get(\"original_has_children_before_move\") === \"true\";",
              "        if (originalHasChildren) {",
              "            // Los hijos deberÃ­an mantenerse (a menos que tu API los quite al mover)",
              "            pm.expect(responseData.children.length).to.be.greaterThan(0);",
              "        }",
              "    });",
              "}",
              "",
              "// 15. Verificar headers de respuesta",
              "pm.test(\"Headers de respuesta correctos\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ… Content-Type: ${contentType}`);",
              "});",
              "",
              "// 16. Verificar tiempo de respuesta",
              "pm.test(\"Tiempo de respuesta aceptable\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(1000);",
              "    console.log(`âœ… Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "    ",
              "    if (pm.response.responseTime > 500) {",
              "        console.log(\"âš  Tiempo de respuesta mayor a 500ms\");",
              "    }",
              "});",
              "",
              "// 17. Verificar que no hay errores en la respuesta",
              "pm.test(\"Respuesta no contiene errores\", function () {",
              "    if (responseData) {",
              "        pm.expect(responseData).to.not.have.property(\"error\");",
              "        pm.expect(responseData).to.not.have.property(\"detail\");",
              "        pm.expect(responseData).to.not.have.property(\"non_field_errors\");",
              "    }",
              "});",
              "",
              "// 18. Validaciones adicionales de integridad",
              "if (responseData) {",
              "    pm.test(\"Integridad de datos despuÃ©s de mover\", function () {",
              "        // ID positivo",
              "        pm.expect(responseData.id).to.be.greaterThan(0);",
              "        ",
              "        // Content no vacÃ­o",
              "        pm.expect(responseData.content.trim().length).to.be.greaterThan(0);",
              "        ",
              "        // Title no vacÃ­o",
              "        pm.expect(responseData.title.trim().length).to.be.greaterThan(0);",
              "        ",
              "        // Children es array",
              "        pm.expect(Array.isArray(responseData.children)).to.be.true;",
              "        ",
              "        // Formato de fecha vÃ¡lido",
              "        pm.expect(responseData.created_at).to.match(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);",
              "    });",
              "}",
              "",
              "// 19. RESUMEN FINAL",
              "if (responseData) {",
              "    console.log(\"\\n\" + \"=\".repeat(60));",
              "    console.log(\"âœ… NODO MOVIDO EXITOSAMENTE\");",
              "    console.log(\"=\".repeat(60));",
              "    console.log(`Nodo ID: ${responseData.id}`);",
              "    console.log(`Content: \"${responseData.content}\"`);",
              "    console.log(`Title (automÃ¡tico): \"${responseData.title}\"`);",
              "    ",
              "    // Mostrar parent anterior y nuevo",
              "    const originalParent = pm.environment.get(\"original_parent_before_move\");",
              "    if (originalParent) {",
              "        console.log(`Parent anterior: ${originalParent === \"null\" ? \"RaÃ­z\" : originalParent}`);",
              "    }",
              "    console.log(`Parent nuevo: ${responseData.parent === null ? \"RaÃ­z\" : responseData.parent}`);",
              "    ",
              "    console.log(`Hijos: ${responseData.children.length} nodos`);",
              "    console.log(`Creado: ${responseData.created_at}`);",
              "    console.log(\"=\".repeat(60));",
              "    ",
              "    // Guardar datos para posibles tests futuros",
              "    pm.environment.set(\"last_moved_node_id\", responseData.id.toString());",
              "    pm.environment.set(\"last_moved_node_parent\", responseData.parent === null ? \"null\" : responseData.parent.toString());",
              "    ",
              "    // Limpiar variables temporales",
              "    pm.environment.unset(\"original_content_before_move\");",
              "    pm.environment.unset(\"original_parent_before_move\");",
              "    pm.environment.unset(\"original_children_ids_before_move\");",
              "    pm.environment.unset(\"original_has_children_before_move\");",
              "    pm.environment.unset(\"original_created_at_before_move\");",
              "}",
              "",
              "console.log(\"=== Test de cambio de parent ID completado ===\");",
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "PATCH",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"parent\": 2\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_1}}/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_1}}",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Patch_ID_Node_Create_1_Must_Fail",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// ============================================",
              "// TEST: Error al mover nodo - Parent no existe",
              "// Escenario: Intentar mover nodo a parent ID 999 que no existe",
              "// ============================================",
              "",
              "console.log(\"=== Test: Error - Parent ID no existe ===\");",
              "",
              "// 1. Verificar que falla con status 400 Bad Request",
              "pm.test(\"Status code es 400 Bad Request\", function () {",
              "    pm.response.to.have.status(400);",
              "});",
              "",
              "// 2. Parsear respuesta JSON del error",
              "let responseData = null;",
              "try {",
              "    responseData = pm.response.json();",
              "    pm.test(\"Error response es JSON vÃ¡lido\", function () {",
              "        pm.expect(responseData).to.be.an(\"object\");",
              "    });",
              "} catch (e) {",
              "    pm.test(\"Error response es JSON vÃ¡lido\", function () {",
              "        pm.expect.fail(\"La respuesta no es JSON vÃ¡lido: \" + e.message);",
              "    });",
              "}",
              "",
              "// 3. DEBUG: Mostrar quÃ© se intentÃ³ hacer",
              "const requestBody = JSON.parse(pm.request.body.raw || \"{}\");",
              "console.log(`DEBUG - Intento de mover nodo:`);",
              "console.log(`  Nodo ID: ${pm.environment.get(\"node_to_move_id\") || \"Desconocido\"}`);",
              "console.log(`  Parent ID objetivo: ${requestBody.parent}`);",
              "console.log(`  Parent ID no existe: 999`);",
              "",
              "// 4. Verificar estructura especÃ­fica del error",
              "if (responseData) {",
              "    console.log(\"Estructura completa del error:\", JSON.stringify(responseData, null, 2));",
              "    ",
              "    // 5. Verificar que el error es especÃ­fico del campo \"parent\"",
              "    pm.test(\"Error estÃ¡ en campo 'parent'\", function () {",
              "        pm.expect(responseData).to.have.property(\"parent\");",
              "        pm.expect(responseData.parent).to.be.an(\"array\");",
              "        pm.expect(responseData.parent.length).to.be.greaterThan(0);",
              "    });",
              "    ",
              "    // 6. Verificar mensaje de error especÃ­fico",
              "    const errorMessage = responseData.parent[0];",
              "    pm.test(\"Mensaje de error es el esperado\", function () {",
              "        pm.expect(errorMessage).to.equal('Invalid pk \"999\" - object does not exist.');",
              "        console.log(`âœ… Mensaje de error correcto: \"${errorMessage}\"`);",
              "    });",
              "    ",
              "    // 7. Verificar que el error menciona el ID especÃ­fico (999)",
              "    pm.test(\"Error menciona el ID incorrecto\", function () {",
              "        pm.expect(errorMessage).to.include(\"999\");",
              "        pm.expect(errorMessage).to.include(\"object does not exist\");",
              "    });",
              "    ",
              "    // 8. Verificar que NO tiene propiedades de Ã©xito",
              "    pm.test(\"No es una respuesta exitosa\", function () {",
              "        pm.expect(responseData).to.not.have.property(\"id\");",
              "        pm.expect(responseData).to.not.have.property(\"title\");",
              "        pm.expect(responseData).to.not.have.property(\"children\");",
              "        pm.expect(responseData).to.not.have.property(\"created_at\");",
              "    });",
              "    ",
              "    // 9. Verificar que solo tiene el campo \"parent\" con error",
              "    pm.test(\"Estructura de error minimalista\", function () {",
              "        const keys = Object.keys(responseData);",
              "        console.log(`Campos en error response: ${keys.join(\", \")}`);",
              "        pm.expect(keys).to.have.lengthOf(1);",
              "        pm.expect(keys[0]).to.equal(\"parent\");",
              "    });",
              "}",
              "",
              "// 10. Verificar headers de respuesta",
              "pm.test(\"Headers de respuesta correctos para error\", function () {",
              "    const contentType = pm.response.headers.get(\"Content-Type\");",
              "    pm.expect(contentType).to.include(\"application/json\");",
              "    console.log(`âœ… Content-Type: ${contentType}`);",
              "    ",
              "    // Errores no deberÃ­an ser cacheados",
              "    const cacheControl = pm.response.headers.get(\"Cache-Control\");",
              "    if (cacheControl) {",
              "        console.log(`âœ… Cache-Control: ${cacheControl}`);",
              "    }",
              "});",
              "",
              "// 11. Verificar tiempo de respuesta (debe ser rÃ¡pido para error)",
              "pm.test(\"Tiempo de respuesta rÃ¡pido\", function () {",
              "    pm.expect(pm.response.responseTime).to.be.below(200);",
              "    console.log(`âœ… Tiempo de respuesta: ${pm.response.responseTime}ms`);",
              "});",
              "",
              "// 12. Test de integridad del error",
              "pm.test(\"Integridad del error 400\", function () {",
              "    const criticalChecks = [",
              "        { name: \"Status 400\", check: pm.response.code === 400 },",
              "        { name: \"Es JSON\", check: responseData !== null },",
              "        { name: \"Tiene error en parent\", check: responseData && responseData.parent && Array.isArray(responseData.parent) },",
              "        { name: \"Mensaje especÃ­fico\", check: responseData && responseData.parent && ",
              "            responseData.parent[0] === 'Invalid pk \"999\" - object does not exist.' }",
              "    ];",
              "    ",
              "    let allPassed = true;",
              "    criticalChecks.forEach(check => {",
              "        console.log(`${check.name}: ${check.check ? 'âœ…' : 'âŒ'}`);",
              "        if (!check.check) allPassed = false;",
              "    });",
              "    ",
              "    pm.expect(allPassed, \"Fallo una verificaciÃ³n crÃ­tica del error\").to.be.true;",
              "    console.log(\"âœ… Todas las verificaciones crÃ­ticas pasaron\");",
              "});",
              "",
              "// 13. RESUMEN FINAL DEL ERROR",
              "console.log(\"\\n\" + \"=\".repeat(60));",
              "console.log(\"âœ… COMPORTAMIENTO ESPERADO CONFIRMADO\");",
              "console.log(\"=\".repeat(60));",
              "console.log(\"La API correctamente rechazÃ³ el movimiento porque:\");",
              "console.log(\"1. âŒ Parent ID 999 no existe en la base de datos\");",
              "console.log(\"2. âœ… RetornÃ³ status 400 Bad Request\");",
              "console.log(\"3. âœ… Mensaje de error claro y especÃ­fico\");",
              "console.log(\"4. âœ… Error en campo 'parent' (no en otro campo)\");",
              "console.log(\"=\".repeat(60));",
              "",
              "// 14. Guardar informaciÃ³n del error para referencia",
              "if (responseData && responseData.parent) {",
              "    pm.environment.set(\"last_parent_not_found_error\", JSON.stringify({",
              "        timestamp: new Date().toISOString(),",
              "        attempted_parent_id: 999,",
              "        error_message: responseData.parent[0],",
              "        status_code: 400,",
              "        response_time: pm.response.responseTime",
              "    }));",
              "}",
              "",
              "console.log(\"=== Test de error por parent no existente completado ===\");",
              ""
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "PATCH",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"parent\": 999\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_1}}/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_1}}",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Delete_Node_Create_1_Must_Fail",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// TEST SIMPLE: No se puede eliminar nodo con hijos",
              "",
              "console.log(\"=== Test Simple: Nodo con hijos no se puede eliminar ===\");",
              "",
              "// 1. Status 400",
              "pm.test(\"Status 400 Bad Request\", function() {",
              "    pm.response.to.have.status(400);",
              "});",
              "",
              "// 2. Parse error",
              "const error = pm.response.json();",
              "",
              "// 3. Verificar mensaje exacto",
              "pm.test(\"Mensaje de error correcto\", function() {",
              "    pm.expect(error).to.have.property(\"error\");",
              "    pm.expect(error.error).to.equal(\"No se puede eliminar un nodo que tiene hijos activos.\");",
              "});",
              "",
              "// 4. Mostrar informaciÃ³n",
              "if (error.error) {",
              "    console.log(`âœ… Error esperado: \"${error.error}\"`);",
              "    ",
              "    // Extraer ID de la URL",
              "    const url = pm.request.url.toString();",
              "    const idMatch = url.match(/\\/nodes\\/(\\d+)\\//);",
              "    if (idMatch) {",
              "        console.log(`âœ… Nodo ID ${idMatch[1]} tiene hijos activos`);",
              "        console.log(`âœ… Correctamente rechazÃ³ la eliminaciÃ³n`);",
              "    }",
              "}",
              "",
              "// 5. Performance",
              "pm.test(\"Respuesta rÃ¡pida\", function() {",
              "    pm.expect(pm.response.responseTime).to.be.below(100);",
              "});",
              "",
              "console.log(\"âœ… Test completado - Integridad del Ã¡rbol protegida\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "DELETE",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_1}}/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_1}}",
            ""
          ]
        }
      },
      "response": []
    },
    {
      "name": "Delete_Node_Create_2",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// TEST: Verificar que nodo padre ahora puede eliminarse",
              "",
              "console.log(\"=== Test: Verificar eliminaciÃ³n de nodo padre ===\");",
              "",
              "// Este test se ejecuta DESPUÃ‰S de eliminar el nodo hijo",
              "",
              "// 1. Status 204 (si se elimina) o 400 (si aÃºn tiene hijos)",
              "const status = pm.response.code;",
              "",
              "if (status === 204) {",
              "    console.log(\"âœ… Status 204 - Nodo padre eliminado exitosamente\");",
              "    ",
              "    pm.test(\"EliminaciÃ³n exitosa\", function() {",
              "        pm.response.to.have.status(204);",
              "    });",
              "    ",
              "    // Limpiar CAPTURE_NODE_ID_1",
              "    pm.environment.unset(\"CAPTURE_NODE_ID_1\");",
              "    console.log(`âœ… CAPTURE_NODE_ID_1 eliminado de variables`);",
              "    ",
              "} else if (status === 400) {",
              "    console.log(\"âœ… Status 400 - Nodo padre aÃºn no se puede eliminar\");",
              "    ",
              "    const error = pm.response.json();",
              "    if (error.error && error.error.includes(\"hijos\")) {",
              "        console.log(`âŒ AÃºn tiene hijos: \"${error.error}\"`);",
              "        ",
              "        // Verificar quÃ© hijos quedan",
              "        const parentId = pm.environment.get(\"CAPTURE_NODE_ID_1\");",
              "        if (parentId) {",
              "            console.log(`ðŸ’¡ El nodo padre ${parentId} aÃºn tiene hijos activos`);",
              "            console.log(`ðŸ’¡ Necesitas eliminarlos primero`);",
              "        }",
              "    }",
              "}",
              "",
              "// 2. Mostrar estado actual",
              "console.log(`\\nðŸ“Š ESTADO ACTUAL DE VARIABLES:`);",
              "console.log(`   CAPTURE_NODE_ID_1: ${pm.environment.get(\"CAPTURE_NODE_ID_1\") || \"ELIMINADO/NO DEFINIDO\"}`);",
              "console.log(`   CAPTURE_NODE_ID_2: ${pm.environment.get(\"CAPTURE_NODE_ID_2\") || \"ELIMINADO/NO DEFINIDO\"}`);",
              "",
              "console.log(\"âœ… Test de verificaciÃ³n completado\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "DELETE",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_2}}/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_2}}",
            ""
          ]
        },
        "description": "Este debe ser exitoso dado que no hay nadie por debajo de el"
      },
      "response": []
    },
    {
      "name": "Delete_Node_Create_1_Succed",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// TEST: Verificar que nodo padre ahora puede eliminarse",
              "",
              "console.log(\"=== Test: Verificar eliminaciÃ³n de nodo padre ===\");",
              "",
              "// Este test se ejecuta DESPUÃ‰S de eliminar el nodo hijo",
              "",
              "// 1. Status 204 (si se elimina) o 400 (si aÃºn tiene hijos)",
              "const status = pm.response.code;",
              "",
              "if (status === 204) {",
              "    console.log(\"âœ… Status 204 - Nodo padre eliminado exitosamente\");",
              "    ",
              "    pm.test(\"EliminaciÃ³n exitosa\", function() {",
              "        pm.response.to.have.status(204);",
              "    });",
              "    ",
              "    // Limpiar CAPTURE_NODE_ID_1",
              "    pm.environment.unset(\"CAPTURE_NODE_ID_1\");",
              "    console.log(`âœ… CAPTURE_NODE_ID_1 eliminado de variables`);",
              "    ",
              "} else if (status === 400) {",
              "    console.log(\"âœ… Status 400 - Nodo padre aÃºn no se puede eliminar\");",
              "    ",
              "    const error = pm.response.json();",
              "    if (error.error && error.error.includes(\"hijos\")) {",
              "        console.log(`âŒ AÃºn tiene hijos: \"${error.error}\"`);",
              "        ",
              "        // Verificar quÃ© hijos quedan",
              "        const parentId = pm.environment.get(\"CAPTURE_NODE_ID_1\");",
              "        if (parentId) {",
              "            console.log(`ðŸ’¡ El nodo padre ${parentId} aÃºn tiene hijos activos`);",
              "            console.log(`ðŸ’¡ Necesitas eliminarlos primero`);",
              "        }",
              "    }",
              "}",
              "",
              "// 2. Mostrar estado actual",
              "console.log(`\\nðŸ“Š ESTADO ACTUAL DE VARIABLES:`);",
              "console.log(`   CAPTURE_NODE_ID_1: ${pm.environment.get(\"CAPTURE_NODE_ID_1\") || \"ELIMINADO/NO DEFINIDO\"}`);",
              "console.log(`   CAPTURE_NODE_ID_2: ${pm.environment.get(\"CAPTURE_NODE_ID_2\") || \"ELIMINADO/NO DEFINIDO\"}`);",
              "",
              "console.log(\"âœ… Test de verificaciÃ³n completado\");"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "DELETE",
        "header": [],
        "url": {
          "raw": "{{LOCAL}}/nodes/{{CAPTURE_NODE_ID_1}}/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "nodes",
            "{{CAPTURE_NODE_ID_1}}",
            ""
          ]
        },
        "description": "Este debe ser exitoso dado que no hay nadie por debajo de el"
      },
      "response": []
    },
    {
      "name": "Get_Users",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "console.log(\"=== Pre-request: Login y obtenciÃ³n de tokens ===\");",
              "",
              "// ConfiguraciÃ³n bÃ¡sica",
              "const baseUrl = pm.environment.get(\"base_url\") || pm.globals.get(\"LOCAL\");",
              "const username = pm.environment.get(\"SUDOUSERNAME\") || pm.globals.get(\"SUDOUSERNAME\");",
              "const password = pm.environment.get(\"SUDOUSERPASS\") || pm.globals.get(\"SUDOUSERPASS\");",
              "",
              "if (!baseUrl) {",
              "    throw new Error(\"No se encontrÃ³ 'base_url' ni 'LOCAL'. Configura una de estas variables (ej: http://localhost:8000).\");",
              "}",
              "if (!username || !password) {",
              "    throw new Error(\"Variables SUDOUSERNAME o SUDOUSERPASS no estÃ¡n definidas.\");",
              "}",
              "",
              "const loginUrl = baseUrl.replace(/\\/+$/, \"\") + \"/token/\"; // o \"/api/token/\" segÃºn tu backend",
              "",
              "const loginRequest = {",
              "    url: loginUrl,",
              "    method: \"POST\",",
              "    header: {",
              "        \"Content-Type\": \"application/json\",",
              "        \"Accept\": \"application/json\"",
              "    },",
              "    body: {",
              "        mode: \"raw\",",
              "        raw: JSON.stringify({",
              "            username: username,",
              "            password: password",
              "        })",
              "    }",
              "};",
              "",
              "pm.sendRequest(loginRequest, function (err, response) {",
              "    if (err) {",
              "        console.error(\"Error en login:\", err);",
              "        throw new Error(\"No se pudo obtener tokens: \" + err.message);",
              "    }",
              "",
              "    if (response.code !== 200) {",
              "        console.log(\"Body login:\", response.text());",
              "        throw new Error(\"Login fallÃ³. CÃ³digo: \" + response.code);",
              "    }",
              "",
              "    let loginData;",
              "    try {",
              "        loginData = response.json();",
              "    } catch (e) {",
              "        throw new Error(\"La respuesta de login no es JSON vÃ¡lido.\");",
              "    }",
              "",
              "    if (!loginData.access || !loginData.refresh) {",
              "        console.log(\"Body login:\", loginData);",
              "        throw new Error(\"La respuesta de login no contiene 'access' y/o 'refresh'.\");",
              "    }",
              "",
              "    // Guardar tokens para otros requests, si los necesitas",
              "    pm.environment.set(\"access_token\", loginData.access);",
              "    pm.environment.set(\"refresh_token\", loginData.refresh);",
              "    pm.environment.set(\"temp_access_token\", loginData.access);",
              "    pm.environment.set(\"temp_refresh_token\", loginData.refresh);",
              "",
              "    // Asegurar solo headers, NO tocar el body",
              "    pm.request.headers.upsert({",
              "        key: \"Content-Type\",",
              "        value: \"application/json\"",
              "    });",
              "    pm.request.headers.upsert({",
              "        key: \"Accept\",",
              "        value: \"application/json\"",
              "    });",
              "",
              "    // âš  NO actualizar el body aquÃ­, dejamos el body invÃ¡lido que seteaste tÃº a mano",
              "    // pm.request.body.update({ ... });",
              "",
              "    console.log(\"âœ“ Login OK. Usando body de refresh tal como estÃ¡ configurado en el request (deberÃ­a ser invÃ¡lido).\");",
              "});"
            ],
            "type": "text/javascript",
            "packages": {},
            "requests": {}
          }
        }
      ],
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      },
      "request": {
        "auth": {
          "type": "bearer",
          "bearer": [
            {
              "key": "token",
              "value": "{{access_token}}",
              "type": "string"
            }
          ]
        },
        "method": "GET",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": ""
        },
        "url": {
          "raw": "{{LOCAL}}/users/",
          "host": [
            "{{LOCAL}}"
          ],
          "path": [
            "users",
            ""
          ]
        }
      },
      "response": []
    }
  ]
}